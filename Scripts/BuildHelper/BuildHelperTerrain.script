{$IFNDEF BuildHelperTerrain}
{$DEFINE BuildHelperTerrain}

{$INCLUDE BuildHelperGlobal.script}

{$EVENT evtTick:BH_OnTickTerrain}
{$EVENT evtRoadBuilt:BH_OnRoadBuiltTerrain}
{$EVENT evtHousePlanPlacedEx:BH_OnHousePlanPlacedExTerrain}
{$EVENT evtHousePlanRemovedEx:BH_OnHousePlanRemovedExTerrain}
{$EVENT evtPlanRoadPlaced:BH_OnPlanRoadPlacedTerrain}
{$EVENT evtPlanRoadRemoved:BH_OnPlanRoadRemovedTerrain}
{$EVENT evtHouseBuilt:BH_OnHouseBuiltTerrain}
{$EVENT evtHouseDestroyed:BH_OnHouseDestroyedTerrain}
{$EVENT evtMissionStart:BH_OnMissionStartTerrain}

{$COMMAND GetRoadInfo:BH_GetRoadInfo}

//----------------------------------------------------------------------------------------------------------------------------------------------------
//PATH FIND.
//----------------------------------------------------------------------------------------------------------------------------------------------------

function BH_GetDistance(firstX, firstY, secondX, secondY: integer): Single;
begin
  result := U.Power(((firstX - secondX)*(firstX - secondX) + (firstY - secondY)*(firstY - secondY)), 0.5);
end;

function BH_GetDistanceEx(first, second: TKMPoint): Single;
begin
  result := U.Power(((first.X - second.X)*(first.X - second.X) + (first.Y - second.Y)*(first.Y - second.Y)), 0.5);
end;

function BH_GetPathSearchHashValue(fromX, fromY, toX, toY: integer): single;
begin
  result := fromX;
  result := result * fromY;
  result := result / toX;
  result := result / toY;
end;

function BH_ExistsWalkablePath(fromX, fromY, toX, toY, currentDepth, maxDepth: integer; hash: Single): boolean;
begin

  result := false;

  if (BH_MapTilesInfo[fromX][fromY].PathSearchHash = hash) then
  begin
    exit;
  end;

  BH_MapTilesInfo[fromX][fromY].PathSearchHash := hash;

  if (currentDepth > maxDepth) then
  begin
    exit;
  end;

  //If we found a tile that is neighbor to bordertile and it's walkable - path exists.
  if ((U.AbsI(fromX - toX) < 2) and (U.AbsI(fromY - toY) < 2)) then
  begin

    //Check passability. Don't want to move passability check to the top of function. Not sure about it performance.
    if (S.MapTilePassabilityEx(fromX, fromY, tpWalk))then
    begin
      result := true;
      exit;
    end;
  end;

  if (BH_GetDistance(fromX, fromY, toX, toY) > (maxDepth - currentDepth)) then
  begin
    exit;
  end;

  //TODO. Think about objects such as trees. They can affect it as well.
  if (not S.MapTilePassabilityEx(fromX, fromY, tpWalk))then
  begin
    exit;
  end;

  //A.Log('from ' + IntToStr(fromX) + ',' + IntToStr(fromY) + ' to ' + IntToStr(toX) + ',' + IntToStr(toY));

  //Think how to optimize it.
  //TODO. Make algorithm of searching best way to the point. Not stupid roll of all directions.
  //TODO. Include check for equal.
  if (toX > fromX) then
  begin

    if (toY > fromY) then
    begin

      if (BH_ExistsWalkablePath(fromX+1, fromY+1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX+1, fromY, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX, fromY+1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX, fromY-1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX-1, fromY, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX-1, fromY+1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX+1, fromY-1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX-1, fromY-1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

    end else
    begin

      if (BH_ExistsWalkablePath(fromX+1, fromY-1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX+1, fromY, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX, fromY-1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX, fromY+1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX-1, fromY, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX+1, fromY+1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX-1, fromY-1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX-1, fromY+1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;
    end;
  end else
  begin
    if (toY > fromY) then
    begin

      if (BH_ExistsWalkablePath(fromX-1, fromY+1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX-1, fromY, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX, fromY+1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX, fromY-1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX+1, fromY, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX-1, fromY-1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX+1, fromY+1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX+1, fromY-1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

    end else
    begin

      if (BH_ExistsWalkablePath(fromX-1, fromY-1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX-1, fromY, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX, fromY-1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX, fromY+1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX+1, fromY, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX-1, fromY+1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX+1, fromY-1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;

      if (BH_ExistsWalkablePath(fromX+1, fromY+1, toX, toY, currentDepth + 1, maxDepth, hash)) then
      begin
        result := true;
        exit;
      end;
    end;
  end;


end;

//----------------------------------------------------------------------------------------------------------------------------------------------------
//IRON AND GOLD MINES.
//----------------------------------------------------------------------------------------------------------------------------------------------------

function BH_IsMapPoint(x,y: integer): boolean;
begin
  result := (x > 0) and (y > 0) and (x < S.MapWidth) and (y < S.MapHeight);
end;

function BH_ComparePoints(point: TKMPoint; x,y: integer): boolean;
begin
  result := (point.X = x) and (point.Y = y);
end;

function BH_SafeMapTileIsIron(x,y: integer): boolean;
begin

  result := false;
  if (BH_IsMapPoint(x,y)) then
  begin
    result := S.MapTileIsIron(x, y);
  end;
end;

function BH_SafeMapTileIsGold(x,y: integer): boolean;
begin

  result := false;
  if (BH_IsMapPoint(x,y)) then
  begin
    result := S.MapTileIsGold(x, y);
  end;
end;

function BH_IsIronTile(x,y: integer): boolean;
begin
  result := BH_SafeMapTileIsIron(x, y-1) or BH_SafeMapTileIsIron(x-1, y-1) or BH_SafeMapTileIsIron(x+1, y-1) or BH_SafeMapTileIsIron(x-2, y-1) or BH_SafeMapTileIsIron(x+2, y-1);
end;

function BH_IsGoldTile(x,y: integer): boolean;
begin
  result := BH_SafeMapTileIsGold(x, y-1) or BH_SafeMapTileIsGold(x-1, y-1) or BH_SafeMapTileIsGold(x+1, y-1) or BH_SafeMapTileIsGold(x-2, y-1);
end;

function BH_SafeHouseAt(x, y: integer): integer;
begin
  result := -1;

  if (BH_IsMapPoint(x,y)) then
  begin
    result := S.HouseAt(x,y);
  end;
end;

function BH_CanBuildIronMine(x, y: integer): boolean;
begin

  result := (BH_SafeHouseAt(x-2,y-1) = -1) and (BH_SafeHouseAt(x-2,y  ) = -1) and (BH_SafeHouseAt(x-2,y+1) = -1) and
            (BH_SafeHouseAt(x-1,y+1) = -1) and (BH_SafeHouseAt(x  ,y+1) = -1) and (BH_SafeHouseAt(x+1,y+1) = -1) and
            (BH_SafeHouseAt(x+2,y+1) = -1) and (BH_SafeHouseAt(x+2,y  ) = -1) and (BH_SafeHouseAt(x+2,y-1) = -1);
end;

function BH_CanBuildGoldMine(x, y: integer): boolean;
begin

  result := (BH_SafeHouseAt(x-2,y-1) = -1) and (BH_SafeHouseAt(x-2,y  ) = -1) and (BH_SafeHouseAt(x-2,y+1) = -1) and
            (BH_SafeHouseAt(x-1,y+1) = -1) and (BH_SafeHouseAt(x  ,y+1) = -1) and
            (BH_SafeHouseAt(x+1,y+1) = -1) and (BH_SafeHouseAt(x+1,y  ) = -1) and (BH_SafeHouseAt(x+1,y-1) = -1);
end;

function BH_ExistsPoint(points: array of TKMPoint; x,y: integer): boolean;
var
  i: integer;

begin

  result := false;

  for i:=0 to High(points) do
  begin

    if ((points[i].X = x) and (points[i].Y = y)) then
    begin

      result := true;
      exit;
    end;
  end;
end;

function BH_ReverseExistPoint(points: array of TKMPoint; x,y: integer): boolean;
var
  i: integer;

begin

  result := false;

  for i:=0 to High(points) do
  begin

    if ((points[High(points)-i].X = x) and (points[High(points)-i].Y = y)) then
    begin

      result := true;
      exit;
    end;
  end;
end;

function BH_UniteTKMPointArrays(first, second: array of TKMPoint): array of TKMPoint;
var
  i: integer;
begin

  for i:= 0 to High(first) do
  begin
    setLength(result, Length(result) +1);
    result[High(Result)].X := first[i].X;
    result[High(Result)].Y := first[i].Y;
  end;

  for i:= 0 to High(second) do
  begin
    //if (not BH_ExistsPoint(result, second[i].X, second[i].Y)) then
    //begin
      setLength(result, Length(result) +1);
      result[High(Result)].X := second[i].X;
      result[High(Result)].Y := second[i].Y;
    //end;
  end;
end;

function BH_RemovePoint(points: array of TKMPoint; x,y: integer): array of TKMPoint;
var
  i: integer;

begin

  result := points;

  for i:=0 to High(result) do
  begin
    if ((result[i].X = x) and (result[i].Y = y)) then
    begin

      result[i].X := result[High(result)].X;
      result[i].Y := result[High(result)].Y;

      SetLength(result, Length(result) - 1);
      exit;
    end;
  end;
end;

function BH_AddPoint(points: array of TKMPoint; x,y: integer): array of TKMPoint;
begin
  result := points;
  SetLength(result, Length(result) + 1);
  result[High(result)].X := x;
  result[High(result)].Y := y;
end;

function BH_AddUniquePoint(points: array of TKMPoint; x,y: integer): array of TKMPoint;
begin

  if (not BH_ExistsPoint(points, x, y)) then
  begin
    result := BH_AddPoint(points, x, y);
  end else
  begin
    result := points;
  end;

end;

function BH_AreConflictingPoints(conflicts: array of array of TKMPoint; x1, y1, x2, y2: integer): boolean;
var
  i: integer;
  j: integer;
  firstExist: boolean;
  secondExist: boolean;

begin

  result := false;
  for i := 0 to High(conflicts) do
  begin

    firstExist := false;
    secondExist := false;

    for j := 0 to High(conflicts[i]) do
    begin

      if ((conflicts[i][j].X = x1) and (conflicts[i][j].Y = y1)) then
      begin
        firstExist:= true;
      end;
      if ((conflicts[i][j].X = x2) and (conflicts[i][j].Y = y2)) then
      begin
        secondExist:= true;
      end;

    end;

    if (firstExist and secondExist) then
    begin
      result := true;
      exit;
    end;
  end;
end;

function BH_ExistsConflictingPoint(conflicts: array of array of TKMPoint; points: array of TKMPoint; x, y: integer): boolean;
var
  i: integer;

begin

  result := false;
  for i:= 0 to High(points) do
  begin

    if(BH_AreConflictingPoints(conflicts, points[i].X, points[i].Y, x, y)) then
    begin

      result := true;
      exit;
    end;
  end;

end;

function BH_FillConflictingPoints(conflicts: array of array of TKMPoint; points: array of TKMPoint; x, y: integer): array of TKMPoint;
var
  i: integer;
  j: integer;
  index: integer;

begin

  result := points;

  for i := 0 to High(conflicts) do
  begin

    if (not BH_ExistsPoint(conflicts[i], x, y)) then
    begin
      continue;
    end;

    index:= Length(result);
    SetLength(result, Length(result) + Length(conflicts[i]));

    for j := 0 to High(conflicts[i]) do
    begin

      result[index].X := conflicts[i][j].X;
      result[index].Y := conflicts[i][j].Y;
      Inc(index);

    end;
  end;
end;

function BH_GetPlayerPossibleIronMines(player: BH_Player): integer;
var
  i: integer;
  x: integer;
  y: integer;
  houseId: integer;
  conflictPoints: array of TKMPoint;
  usedPoints: array of TKMPoint;
begin

  for i:=0 to High(player.CloseIronMinesLocations) do
  begin

    x := player.CloseIronMinesLocations[i].X;
    y := player.CloseIronMinesLocations[i].Y;

    houseId := S.HouseAt(x,y);

    if ((houseId > 0) and (not S.HouseIsComplete(houseId)) and (S.HouseOwner(houseId) = player.Id)) then
    begin

      if (BH_ExistsPoint(conflictPoints, x, y)) then
      begin
        continue;
      end;

      conflictPoints := BH_FillConflictingPoints(BH_IronMinesConflicts, conflictPoints, x,y);
      usedPoints := BH_AddPoint(usedPoints, x,y);

    end else
    if ((houseId = -1) and BH_CanBuildIronMine(x,y)) then
    begin

      if (BH_ExistsPoint(conflictPoints, x, y)) then
      begin
        continue;
      end;

      conflictPoints := BH_FillConflictingPoints(BH_IronMinesConflicts, conflictPoints, x,y);
      usedPoints := BH_AddPoint(usedPoints, x,y);

    end;
  end;

  result := Length(usedPoints);
end;

function BH_GetPlayerPossibleGoldMines(player: BH_Player): integer;
var

  i: integer;
  x: integer;
  y: integer;
  houseId: integer;
  conflictPoints: array of TKMPoint;
  usedPoints: array of TKMPoint;
begin

  //TODO. Think how unite this and BH_GetPlayerPossibleIronMines.

  for i:=0 to High(player.CloseGoldMinesLocations) do
  begin

    x := player.CloseGoldMinesLocations[i].X;
    y := player.CloseGoldMinesLocations[i].Y;

    houseId := S.HouseAt(x,y);

    if ((houseId > 0) and (not S.HouseIsComplete(houseId)) and (S.HouseOwner(houseId) = player.Id)) then
    begin

      if (BH_ExistsPoint(conflictPoints, x, y)) then
      begin
        continue;
      end;

      conflictPoints := BH_FillConflictingPoints(BH_GoldMinesConflicts, conflictPoints, x,y);
      usedPoints := BH_AddPoint(usedPoints, x,y);

    end else
    if ((houseId = -1) and BH_CanBuildGoldMine(x,y)) then
    begin

      if (BH_ExistsPoint(conflictPoints, x, y)) then
      begin
        continue;
      end;

      conflictPoints := BH_FillConflictingPoints(BH_GoldMinesConflicts, conflictPoints, x,y);
      usedPoints := BH_AddPoint(usedPoints, x,y);

    end;
  end;

  result := Length(usedPoints);
end;

procedure BH_TryToAddIronConflicts(x, y, tilesInRow: integer);
var
  i: integer;
  toTile: integer;
  index: integer;
  xLocations: array of integer;

begin

  if (tilesInRow < 4) then
  begin
    exit;
  end;

  repeat

    xLocations := [];
    toTile := U.IfThenI((tilesInRow - 3) > 3, x - tilesInRow + 1 + 3, x - 2);

    for i:= x - tilesInRow + 1 to toTile do
    begin
      SetLength(xLocations, Length(xLocations) + 1);
      xLocations[High(xLocations)] := i;
    end;

    SetLength(BH_IronMinesConflicts, Length(BH_IronMinesConflicts) + 1);
    index := High(BH_IronMinesConflicts);
    SetLength(BH_IronMinesConflicts[index], Length(xLocations));

    for i:= 0 to High(xLocations) do
    begin

      BH_IronMinesConflicts[index][i].X := xLocations[i];
      BH_IronMinesConflicts[index][i].Y := y;
    end;

    Dec(tilesInRow);
  until (tilesInRow < 6);
end;

procedure BH_TryToAddGoldConflicts(x, y, tilesInRow: integer);
var
  i: integer;
  toTile: integer;
  index: integer;
  xLocations: array of integer;

begin

  if (tilesInRow < 3) then
  begin
    exit;
  end;

  repeat

    xLocations := [];
    toTile := U.IfThenI((tilesInRow - 2) > 2, x - tilesInRow + 1 + 2, x - 1);

    for i:= x - tilesInRow + 1 to toTile do
    begin
      SetLength(xLocations, Length(xLocations) + 1);
      xLocations[High(xLocations)] := i;
    end;

    SetLength(BH_GoldMinesConflicts, Length(BH_GoldMinesConflicts) + 1);
    index := High(BH_GoldMinesConflicts);
    SetLength(BH_GoldMinesConflicts[index], Length(xLocations));

    for i:= 0 to High(xLocations) do
    begin

      BH_GoldMinesConflicts[index][i].X := xLocations[i];
      BH_GoldMinesConflicts[index][i].Y := y;
    end;

    Dec(tilesInRow);
  until (tilesInRow < 4);
end;

procedure BH_UpdatePlayerMinesInfo(playerId: integer; location :TKMPoint);
var
  i: integer;
  index : integer;
  hash: single;

begin

  index := BH_FindPlayerIndex(playerId);

  if (index = -1) then
  begin
    exit;
  end;

  for i:= 0 to High(BH_IronMinesLocations) do
  begin

    hash := BH_GetPathSearchHashValue(location.X, location.Y+1, BH_IronMinesLocations[i].X, BH_IronMinesLocations[i].Y);
    //TODO check performance.
    if (BH_ExistsWalkablePath(location.X, location.Y+1, BH_IronMinesLocations[i].X, BH_IronMinesLocations[i].Y, 0, BH_MinesDistance, hash)) then
    //if (BH_GetDistanceEx(location, BH_IronMinesLocations[i]) < BH_MinesDistance) then
    begin

      BH_Players[index].CloseIronMinesLocations := BH_AddUniquePoint(BH_Players[index].CloseIronMinesLocations, BH_IronMinesLocations[i].X, BH_IronMinesLocations[i].Y);
    end;
  end;

  for i:= 0 to High(BH_GoldMinesLocations) do
  begin

    hash := BH_GetPathSearchHashValue(location.X, location.Y+1, BH_GoldMinesLocations[i].X, BH_GoldMinesLocations[i].Y);
    //TODO check performance.
    if (BH_ExistsWalkablePath(location.X, location.Y+1, BH_GoldMinesLocations[i].X, BH_GoldMinesLocations[i].Y, 0, BH_MinesDistance, hash)) then
    //if (BH_GetDistanceEx(location, BH_GoldMinesLocations[i]) < BH_MinesDistance) then
    begin

      BH_Players[index].CloseGoldMinesLocations := BH_AddUniquePoint(BH_Players[index].CloseGoldMinesLocations, BH_GoldMinesLocations[i].X, BH_GoldMinesLocations[i].Y);
    end;
  end;

end;

//----------------------------------------------------------------------------------------------------------------------------------------------------
//ROADS.
//----------------------------------------------------------------------------------------------------------------------------------------------------

function BH_GetRoadCheckHashValue(x, y: integer): single;
begin
  result := x * y;
  result := result / S.GameTime;
end;

procedure BH_InitMapTile(x, y: integer);
var
  unitId: integer;
begin

  if (S.IsRoadAt(-1,x,y)) then
  begin

    BH_MapTilesInfo[x][y].RoadTileType := RTT_Road;
    BH_MapTilesInfo[x][y].RoadConnectionType := RCT_Strong;
  end;

  unitId := S.UnitAt(x,y);
end;

function BH_SafeGetRoadConnectionType(x,y: integer): BH_RoadConnectionType;
begin

  result := RCT_Null;
  if (BH_IsMapPoint(x,y)) then
  begin
    result := BH_MapTilesInfo[x][y].RoadConnectionType;
  end;
end;

function BH_GetBestConnection(first,second: BH_RoadConnectionType): BH_RoadConnectionType;
begin

  if (first = RCT_Strong) then
  begin
    result := first;
    exit;
  end;

  if ((first = RCT_Weak) and (second = RCT_Null)) then
  begin
    result := first;
    exit;
  end;

  result := second;
end;

function BH_GetBestNeighborConnection(x,y: integer): BH_RoadConnectionType;
begin

  result := BH_SafeGetRoadConnectionType(x-1,y);

  if (result = RCT_Strong) then
    exit;

  result := BH_GetBestConnection(result, BH_SafeGetRoadConnectionType(x+1,y));

  if (result = RCT_Strong) then
    exit;

  result := BH_GetBestConnection(result, BH_SafeGetRoadConnectionType(x,y-1));

  if (result = RCT_Strong) then
    exit;

  result := BH_GetBestConnection(result, BH_SafeGetRoadConnectionType(x,y+1));

end;

procedure BH_ConnectRoads(x,y: integer; connectionType: BH_RoadConnectionType);
begin

  BH_MapTilesInfo[x][y].RoadCheckHash := 0;

  if ((not BH_IsMapPoint(x,y)) or (BH_MapTilesInfo[x][y].RoadTileType = RTT_Null)) then
  begin
    exit;
  end;

  if (BH_MapTilesInfo[x][y].RoadConnectionType = RCT_Strong) then
  begin
    exit;
  end;

  if (BH_MapTilesInfo[x][y].RoadConnectionType = connectionType) then
  begin
    exit;
  end;

  if ((connectionType = RCT_Strong) and (BH_MapTilesInfo[x][y].RoadTileType <> RTT_Road)) then
  begin
    exit;
  end;

  BH_MapTilesInfo[x][y].RoadConnectionType := connectionType;

  BH_ConnectRoads(x  , y-1, connectionType);
  BH_ConnectRoads(x  , y+1, connectionType);
  BH_ConnectRoads(x-1, y  , connectionType);
  BH_ConnectRoads(x+1, y  , connectionType);

  //A.Log('Was Connected : ' + IntToStr(x) + ';' + IntToStr(y) + ' ' + IntToStr(BH_MapTilesInfo[x][y].RoadConnectionType));
end;

function BH_CheckConnection(hash: single; x,y: integer): boolean;
begin

  result := false;

  if ((not BH_IsMapPoint(x,y)) or (BH_MapTilesInfo[x][y].RoadTileType = RTT_Null)) then
  begin
    exit;
  end;

  if (BH_MapTilesInfo[x][y].RoadConnectionType = RCT_Strong) then
  begin
    result := true;
    exit;
  end;

  if (BH_MapTilesInfo[x][y].RoadCheckHash = hash) then
  begin
    exit;
  end;

  BH_MapTilesInfo[x][y].RoadCheckHash := hash;

  if (BH_CheckConnection(hash, x  , y-1)) then
  begin
    result := true;
    exit;
  end;

  if (BH_CheckConnection(hash, x  , y+1)) then
  begin
    result := true;
    exit;
  end;

  if (BH_CheckConnection(hash, x-1, y  )) then
  begin
    result := true;
    exit;
  end;

  if (BH_CheckConnection(hash, x+1, y  )) then
  begin
    result := true;
    exit;
  end;
end;

procedure BH_GetRoadInfo(aHandID: Integer; x, y: integer);
begin
  if (BH_IsMapPoint(x,y)) then
  begin
    A.ShowMsg(aHandID, IntToStr(BH_MapTilesInfo[x][y].RoadConnectionType));
  end;

end;

//----------------------------------------------------------------------------------------------------------------------------------------------------
//FISH.
//----------------------------------------------------------------------------------------------------------------------------------------------------

function BH_FindWaterIndex(water: array of BH_Water; waterId: integer):integer;
var
  i: integer;

begin
  result:= -1;
  for i:=0 to High(water) do
  begin
    if (water[i].Id = waterId) then
    begin
      result:= i;
      exit;
    end;
  end;
end;

function BH_SafeIsWaterTile(x,y: integer): boolean;
begin
  result := BH_IsMapPoint(x,y) and S.MapTileIsWater(x, y, false);
end;

function BH_SafeGetWaterIndex(x,y: integer): integer;
begin
  result := -1;
  if (BH_IsMapPoint(x,y)) then
  begin
    result := BH_MapTilesInfo[x][y].WaterIndex;
  end;
end;

function BH_SafeIsWalkableTile(x,y: integer): boolean;
begin
  result := BH_IsMapPoint(x,y) and S.MapTilePassabilityEx(x,y, tpWalk);
end;

function BH_ShoreExists(x,y: integer): boolean;
begin
  result := BH_SafeIsWalkableTile(x-1,y) or BH_SafeIsWalkableTile(x+1,y) or BH_SafeIsWalkableTile(x,y-1) or BH_SafeIsWalkableTile(x,y+1) or
            BH_SafeIsWalkableTile(x-1,y-1) or BH_SafeIsWalkableTile(x+1,y+1) or BH_SafeIsWalkableTile(x+1,y-1) or BH_SafeIsWalkableTile(x-1,y+1);
end;

function BH_FindWaterContinuationIndex(x,y: integer): integer;
begin
  result := BH_SafeGetWaterIndex(x-1,y-1);
  if (result <> -1) then
  begin
    exit;
  end;
  result := BH_SafeGetWaterIndex(x,y-1);
  if (result <> -1) then
  begin
    exit;
  end;
  result := BH_SafeGetWaterIndex(x+1,y-1);
end;

function BH_GetWaterFishCount(waterId: integer): integer;
var
  i: integer;
  index: integer;

begin
  index := BH_FindWaterIndex(BH_FishWater, waterId);

  if (index = -1)then
  begin
    exit;
  end;

  for i:= 0 to High(BH_FishWater[index].Fish) do
  begin
    result := result + S.UnitFishCount(BH_FishWater[index].Fish[i]);
  end;

end;

function BH_GetWaterFishermansCount(playerId, waterId: integer): integer;
var
  i: integer;
  index: integer;
  ownerId: integer;

begin
  index := BH_FindWaterIndex(BH_FishWater, waterId);

  if (index = -1)then
  begin
    exit;
  end;

  result := 0;

  for i:= 0 to High(BH_FishWater[index].Fishermans) do
  begin
    //We do not count enemy fishermans.
    ownerId := S.HouseOwner(BH_FishWater[index].Fishermans[i]);

    if ((playerId = ownerId) or (S.PlayerAllianceCheck(playerId, ownerId))) then
    begin
      Inc(result);
    end;
  end;

end;

function BH_GetPlayerPossibleFishermans(player: BH_Player): integer;
var
  i: integer;
  fishCount: integer;
begin

  result := 0;

  for i:= 0 to High(player.CloseFishWaterIds) do
  begin

    fishCount := BH_GetWaterFishCount(player.CloseFishWaterIds[i]) div 40;

    if (fishCount = 0) then
    begin
      Inc(fishCount);
    end;

    result := result + fishCount - BH_GetWaterFishermansCount(player.Id, player.CloseFishWaterIds[i]);
  end;
end;

procedure BH_RemoveWaterFishermans(houseId: integer);
var
  i: integer;
  index: integer;
begin

  for i:= 0 to High(BH_FishWater) do
  begin

    index := BH_FindTIntegerArrayElementIndex(BH_FishWater[i].Fishermans, houseId);
    if (index <> -1) then
    begin
      BH_FishWater[i].Fishermans := U.ArrayRemoveIndexI(index, BH_FishWater[i].Fishermans);
    end;

  end;
end;

procedure BH_RemovePlayersCloseWater(waterId: integer);
var
  i: integer;
  index : integer;

begin

  for i:= 0 to High(BH_Players) do
  begin

    index := BH_FindTIntegerArrayElementIndex(BH_Players[i].CloseFishWaterIds, waterId);
    if (index <> -1) then
    begin
      BH_Players[i].CloseFishWaterIds := U.ArrayRemoveIndexI(index, BH_Players[i].CloseFishWaterIds);
    end;
  end;
end;

procedure BH_RemoveWater(index: integer);
begin
  BH_RemovePlayersCloseWater(BH_FishWater[index].Id);
  BH_FishWater[index]:=BH_FishWater[High(BH_FishWater)];
  setLength(BH_FishWater, Length(BH_FishWater)-1);
end;

procedure BH_CheckWaterFish();
var
  i: integer;
  j: integer;
begin

  for i:= 0 to High(BH_FishWater) do
  begin
    for j:= 0 to High(BH_FishWater[i].Fish) do
    begin
      if S.UnitDead(BH_FishWater[i].Fish[j]) then
      begin
        BH_FishWater[i].Fish := U.ArrayRemoveIndexI(j, BH_FishWater[i].Fish);
        Dec(j);
      end;
    end;

    if (Length(BH_FishWater[i].Fish) = 0) then
    begin
      BH_RemoveWater(i);
      Dec(i);
    end;

  end;
end;

procedure BH_UpdatePlayerWaterInfo(playerId: integer; houseId: integer);
var
  i: integer;
  j: integer;
  index: integer;
  location: TKMPoint;
  houseType: TKMHouseType;
  hash: single;
begin

  index := BH_FindPlayerIndex(playerId);

  if (index = -1) then
  begin
    exit;
  end;

  location := S.HousePosition(houseId);
  houseType := S.HouseTypeEx(houseId);

  for i:= 0 to High(BH_FishWater) do
  begin

    //TODO. Refactor this.
    if ((houseType <> htFishermans) and U.ArrayHasElementI(BH_FishWater[i].Id, BH_Players[index].CloseFishWaterIds)) then
    begin
      continue;
    end;

    for j:= 0 to High(BH_FishWater[i].Borders) do
    begin

      //TODO check performance.
      hash := BH_GetPathSearchHashValue(location.X, location.Y+1, BH_FishWater[i].Borders[j].X, BH_FishWater[i].Borders[j].Y);
      if (BH_ExistsWalkablePath(location.X, location.Y+1, BH_FishWater[i].Borders[j].X, BH_FishWater[i].Borders[j].Y, 0, BH_FishDistance, hash)) then
      begin

        if (not U.ArrayHasElementI(BH_FishWater[i].Id, BH_Players[index].CloseFishWaterIds)) then
        begin
          setLength(BH_Players[index].CloseFishWaterIds, Length(BH_Players[index].CloseFishWaterIds) + 1);
          BH_Players[index].CloseFishWaterIds[High(BH_Players[index].CloseFishWaterIds)] := BH_FishWater[i].Id;
        end;

        if (houseType = htFishermans) then
        begin
          setLength(BH_FishWater[i].Fishermans, Length(BH_FishWater[i].Fishermans) + 1);
          BH_FishWater[i].Fishermans[High(BH_FishWater[i].Fishermans)] := houseId;
        end;

        break;
      end;

    end;
  end;

end;

procedure BH_FillStartingFishermans();
var
  i: integer;
  j: integer;
  ids: array of integer;
begin

  A.Log(IntToStr(Length(BH_Players)));
  for i:=0 to High(BH_Players) do
  begin

    ids:= S.PlayerGetAllHouses(BH_Players[i].Id);

    A.Log(IntToStr(Length(ids)));

    for j:=0 to High(ids) do
    begin


      if (S.HouseTypeEx(ids[j]) = htFishermans) then
      begin
        BH_UpdatePlayerWaterInfo(BH_Players[i].Id, ids[j]);
      end;
    end;
  end;
end;

procedure BH_FillMapInfo();
var
  i: integer;
  x: integer;
  y: integer;
  tileType: integer;
  ironTilesInRow: integer;
  goldTilesInRow: integer;

  unitId: integer;
  currentWaterIndex: integer;
  neighborWaterIndex: integer;
  fishWater: array of BH_Water;
  index: integer;
begin

  SetLength(BH_MapTilesInfo, S.MapWidth + 1);

  for y:=1 to S.MapWidth - 1 do
  begin
    SetLength(BH_MapTilesInfo[y], S.MapHeight + 1);
  end;

  for y:=1 to S.MapHeight - 1 do
  begin

    BH_TryToAddIronConflicts(x,y,ironTilesInRow);
    ironTilesInRow := 0;

    BH_TryToAddGoldConflicts(x,y-1,goldTilesInRow);
    goldTilesInRow := 0;

    currentWaterIndex:= -1;

    for x:=1 to S.MapWidth - 1 do
    begin

      //Fish water logic.
      if (S.MapTileIsWater(x, y, true)) then
      begin

        //Check if we found border of water, that already was registered.
        if (currentWaterIndex = -1) then
        begin

          currentWaterIndex := BH_FindWaterContinuationIndex(x,y);

          //If we found no water that is connected with this border register new one.
          if (currentWaterIndex = -1) then
          begin

            setLength(fishWater, Length(fishWater) + 1);
            currentWaterIndex := High(fishWater);

            if (BH_ShoreExists(x, y)) then
            begin
              fishWater[currentWaterIndex].Borders := BH_AddPoint(fishWater[currentWaterIndex].Borders, x, y);
            end;
          end;
        end else
        begin
          neighborWaterIndex := BH_FindWaterContinuationIndex(x,y);

          //If we found other water that is connected to this border, that means it's the same water.
          if ((neighborWaterIndex <> -1) and (currentWaterIndex <> neighborWaterIndex)) then
          begin

            //TODO. We have same points in water borders. Find why it happens. Check for unique is bad cause it works crazy slow. Right now better leave this points.
            fishWater[currentWaterIndex].Borders := BH_UniteTKMPointArrays(fishWater[currentWaterIndex].Borders, fishWater[neighborWaterIndex].Borders);
            fishWater[currentWaterIndex].Fish := BH_UniteTIntegerArrays(fishWater[currentWaterIndex].Fish, fishWater[neighborWaterIndex].Fish);

            setLength(fishWater[neighborWaterIndex].Fish, 0);
            setLength(fishWater[neighborWaterIndex].Borders, 0);

            for i:= 1 to S.MapWidth - 1 do
            begin
              if (BH_MapTilesInfo[i][y-1].WaterIndex = neighborWaterIndex) then
              begin
                BH_MapTilesInfo[i][y-1].WaterIndex := currentWaterIndex;
              end;
            end;
          end;

          if (BH_ShoreExists(x, y)) then
          begin
            fishWater[currentWaterIndex].Borders := BH_AddPoint(fishWater[currentWaterIndex].Borders, x, y);
          end;
        end;

        unitId := S.UnitAt(x,y);
        if (unitId <> -1) then
        begin
          if (S.UnitTypeEx(unitId) = utFish) then
          begin

            setLength(fishWater[currentWaterIndex].Fish, Length(fishWater[currentWaterIndex].Fish) +1);
            fishWater[currentWaterIndex].Fish[High(fishWater[currentWaterIndex].Fish)] := unitId;
          end;
        end;

      end else
      begin

        if (currentWaterIndex <> -1) then
        begin

          //Water end. Adding right border.
          if (BH_ShoreExists(x-1, y) and (Length(fishWater[currentWaterIndex].Borders) > 0) and (not BH_ComparePoints(fishWater[currentWaterIndex].Borders[High(fishWater[currentWaterIndex].Borders)], x-1, y))) then
          begin
            fishWater[currentWaterIndex].Borders := BH_AddPoint(fishWater[currentWaterIndex].Borders, x-1, y);
          end;
          currentWaterIndex := -1;

        end;
      end;

      BH_MapTilesInfo[x][y].WaterIndex := currentWaterIndex;

      //Iron and gold logic.
      BH_InitMapTile(x,y);

      tileType := S.MapTileType(x,y);

      if ((tileType = 167) or (tileType = 168)) then
      begin

        BH_TryToAddGoldConflicts(x,y,goldTilesInRow);
        goldTilesInRow := 0;

        if ((S.MapTileRotation(x,y) <> 0) or (not BH_IsIronTile(x,y))) then
        begin

          BH_TryToAddIronConflicts(x,y,ironTilesInRow);
          ironTilesInRow := 0;

          continue;
        end;

        Inc(ironTilesInRow);

        if (ironTilesInRow >= 3) then
        begin

          BH_IronMinesLocations := BH_AddPoint(BH_IronMinesLocations, x-1, y);
        end;


      end else
      if ((tileType = 172) or (tileType = 175))  then
      begin

        BH_TryToAddIronConflicts(x,y,ironTilesInRow);
        ironTilesInRow := 0;

        if ((S.MapTileRotation(x,y) <> 0) or (not BH_IsGoldTile(x,y))) then
        begin
          BH_TryToAddGoldConflicts(x,y,goldTilesInRow);
          goldTilesInRow := 0;
          continue;
        end;

        Inc(goldTilesInRow);

        if (goldTilesInRow >= 2) then
        begin

          BH_GoldMinesLocations := BH_AddPoint(BH_GoldMinesLocations, x, y);
        end;
      end else
      begin

        BH_TryToAddIronConflicts(x,y,ironTilesInRow);
        ironTilesInRow := 0;

        BH_TryToAddGoldConflicts(x,y,goldTilesInRow);
        goldTilesInRow := 0;
      end;
    end;
  end;

  for i := 0 to High(fishWater) do
  begin
    //Save water only with fish.
    if (Length(fishWater[i].Fish) > 0) then
    begin

      setLength(BH_FishWater, Length(BH_FishWater) + 1);
      index := High(BH_FishWater);

      BH_FishWater[index].Id := Length(BH_FishWater);
      BH_FishWater[index].Borders := BH_UniteTKMPointArrays(BH_FishWater[index].Borders, fishWater[i].Borders);
      BH_FishWater[index].Fish := BH_UniteTIntegerArrays(BH_FishWater[index].Fish, fishWater[i].Fish);
    end;
  end;
end;

//----------------------------------------------------------------------------------------------------------------------------------------------------
//BH_BuildingPlanCollection.
//----------------------------------------------------------------------------------------------------------------------------------------------------

function BH_FindBuildingPlanInCollectionIndex(buildingPlans: array of BH_BuildingPlanCollection; buildingType: TKMHouseType): integer;
var
  i: integer;
begin

  result:= -1;
  for i:=0 to High(buildingPlans) do
  begin
    if (buildingPlans[i].BuildingType = buildingType) then
    begin
      result:= i;
      exit;
    end;
  end;
end;

function BH_AddBuildingPlanTypeToCollection(buildingPlans: array of BH_BuildingPlanCollection; buildingType: TKMHouseType): array of BH_BuildingPlanCollection;
var
  index: integer;
begin

  result := buildingPlans;
  index:= BH_FindBuildingPlanInCollectionIndex(result, buildingType);

  if (index <> -1)then
  begin
    exit;
  end;

  setLength(result, Length(result) + 1);
  result[High(result)].BuildingType := buildingType;
end;

procedure BH_AddPlayerBuildingPlan(playerId: integer; buildingType: TKMHouseType; x,y: integer);
var
  playerIndex: integer;
  buildingIndex: integer;
  count: integer;
begin

  playerIndex:= BH_FindPlayerIndex(playerId);

  if (playerIndex = -1) then
  begin
    exit;
  end;

  buildingIndex := BH_FindBuildingPlanInCollectionIndex(BH_Players[playerIndex].BuildingPlans, buildingType);

  if (buildingIndex = -1) then
  begin
    BH_Players[playerIndex].BuildingPlans := BH_AddBuildingPlanTypeToCollection(BH_Players[playerIndex].BuildingPlans, buildingType);
    buildingIndex := High(BH_Players[playerIndex].BuildingPlans);
  end;

  count := Length(BH_Players[playerIndex].BuildingPlans[buildingIndex].Locations);
  setLength(BH_Players[playerIndex].BuildingPlans[buildingIndex].Locations, count + 1);
  BH_Players[playerIndex].BuildingPlans[buildingIndex].Locations[count].X := x;
  BH_Players[playerIndex].BuildingPlans[buildingIndex].Locations[count].Y := y;
end;

procedure BH_RemovePlayerBuildingPlan(playerId: integer; buildingType: TKMHouseType; x,y: integer);
var
  playerIndex: integer;
  buildingIndex: integer;
begin

  playerIndex:= BH_FindPlayerIndex(playerId);

  if (playerIndex = -1) then
  begin
    exit;
  end;

  buildingIndex := BH_FindBuildingPlanInCollectionIndex(BH_Players[playerIndex].BuildingPlans, buildingType);

  if (buildingIndex = -1) then
  begin
    exit;
  end;

  if (BH_ExistsPoint(BH_Players[playerIndex].BuildingPlans[buildingIndex].Locations, x,y)) then
  begin
    BH_Players[playerIndex].BuildingPlans[buildingIndex].Locations := BH_RemovePoint(BH_Players[playerIndex].BuildingPlans[buildingIndex].Locations, x, y);
  end;
end;

//----------------------------------------------------------------------------------------------------------------------------------------------------
//EVENTS.
//----------------------------------------------------------------------------------------------------------------------------------------------------

procedure BH_OnRoadBuiltTerrain(playerId: integer; x, y: integer);
var
  connectionType: BH_RoadConnectionType;

begin

  BH_MapTilesInfo[x][y].RoadTileType := RTT_Road;

  connectionType := BH_GetBestNeighborConnection(x,y);

  if (connectionType <> RCT_Null) then
  begin
    BH_ConnectRoads(x,y, connectionType);
  end;
end;

procedure BH_OnPlanRoadPlacedTerrain(playerId: integer; x, y: integer);
var
  connectionType: BH_RoadConnectionType;

begin

  BH_MapTilesInfo[x][y].RoadTileType := RTT_RoadPlan;

  connectionType := BH_GetBestNeighborConnection(x,y);

  //A.Log('Trying to connect : ' + IntToStr(x) + ';' + IntToStr(y));

  if (connectionType <> RCT_Null) then
  begin

    //A.Log('Connecting : ' + IntToStr(x) + ';' + IntToStr(y) + ' ' + IntToStr(connectionType));
    BH_ConnectRoads(x,y, RCT_Weak);
  end;

end;

procedure BH_OnPlanRoadRemovedTerrain(playerId: integer; x, y: integer);
begin

  BH_MapTilesInfo[x][y].RoadTileType := RTT_Null;
  BH_MapTilesInfo[x][y].RoadConnectionType := RCT_Null;

  if (not BH_CheckConnection(BH_GetRoadCheckHashValue(x,y-1), x  ,y-1)) then
  begin
    BH_ConnectRoads(x,y-1, RCT_Null);
  end;

  if (not BH_CheckConnection(BH_GetRoadCheckHashValue(x,y+1), x  ,y+1)) then
  begin
    BH_ConnectRoads(x,y+1, RCT_Null);
  end;

  if (not BH_CheckConnection(BH_GetRoadCheckHashValue(x-1,y), x-1,y  )) then
  begin
    BH_ConnectRoads(x-1,y, RCT_Null);
  end;

  if (not BH_CheckConnection(BH_GetRoadCheckHashValue(x+1,y), x+1,y  )) then
  begin
    BH_ConnectRoads(x+1,y, RCT_Null);
  end;
end;

procedure BH_OnHousePlanPlacedExTerrain(playerId: integer; x, y: integer; houseType: TKMHouseType);
begin
  BH_AddPlayerBuildingPlan(playerId, houseType, x,y);
end;

procedure BH_OnHousePlanRemovedExTerrain(playerId: integer; x, y: integer; houseType: TKMHouseType);
begin
  BH_RemovePlayerBuildingPlan(playerId, houseType, x,y);
end;

procedure BH_OnHouseBuiltTerrain(aHouse: integer);
var
  ownerId: integer;
  houseType: TKMHouseType;
  location: TKMPoint;

begin
  ownerId := S.HouseOwner(aHouse);
  BH_UpdatePlayerMinesInfo(ownerId, S.HousePosition(aHouse));
  BH_UpdatePlayerWaterInfo(ownerId, aHouse);

  houseType := S.HouseTypeEx(aHouse);
  location := S.HousePosition(aHouse);

  BH_RemovePlayerBuildingPlan(ownerId, houseType, location.X,location.Y);

  if (houseType = htGoldMine) then
  begin

    BH_GoldMinesLocations := BH_RemovePoint(BH_GoldMinesLocations, location.X, location.Y);
  end else
  if (houseType = htIronMine) then
  begin

    BH_IronMinesLocations := BH_RemovePoint(BH_IronMinesLocations, location.X, location.Y);
  end;

end;

procedure BH_OnHouseDestroyedTerrain(aHouse: integer; aDestroyerIndex: integer);
var
  ownerId: integer;
  houseType: TKMHouseType;
  location: TKMPoint;

begin
  ownerId := S.HouseOwner(aHouse);
  houseType := S.HouseTypeEx(aHouse);
  location := S.HousePosition(aHouse);

  BH_RemovePlayerBuildingPlan(ownerId, houseType, location.X,location.Y);

  if (houseType = htGoldMine) then
  begin

    if (S.HouseCanReachResources(aHouse)) then
    begin
      BH_GoldMinesLocations := BH_AddPoint(BH_GoldMinesLocations, location.X, location.Y);
    end;

    //TODO. else remove from all players and remove from conflicts.

  end else
  if (houseType = htIronMine) then
  begin

    if (S.HouseCanReachResources(aHouse)) then
    begin
      BH_IronMinesLocations := BH_AddPoint(BH_IronMinesLocations, location.X, location.Y);
    end;

    //TODO. else remove from all players and remove from conflicts.

  end else
  if (houseType = htFishermans) then
  begin
    BH_RemoveWaterFishermans(aHouse);
  end;

end;

procedure BH_OnMissionStartTerrain;
begin
  BH_FillMapInfo();
end;

procedure BH_OnTickTerrain;
begin

  if (BH_NeedToUpdate and ((S.GameTime - 1) mod 2 = 0)) then
  begin
    BH_Players[BH_MinesUpdateIndex].PossibleIronMinesCount := BH_GetPlayerPossibleIronMines(BH_Players[BH_MinesUpdateIndex]);
    BH_Players[BH_MinesUpdateIndex].PossibleGoldMinesCount := BH_GetPlayerPossibleGoldMines(BH_Players[BH_MinesUpdateIndex]);
    //TODO. Think. Move it from here or rename BH_MinesUpdateIndex. We are updating not only mines here.
    BH_Players[BH_MinesUpdateIndex].PossibleFishermansCount := BH_GetPlayerPossibleFishermans(BH_Players[BH_MinesUpdateIndex]);

    Inc(BH_MinesUpdateIndex);

    if BH_MinesUpdateIndex > High(BH_Players) then
    begin
      BH_MinesUpdateIndex := 0;
      BH_NeedToUpdate := false;
    end;
  end;

  if ((S.GameTime - 1) mod (10 * BH_Seconds) = 0) then
  begin
    BH_NeedToUpdate:= true;
  end;

  if (S.GameTime mod (10 * BH_Seconds) = 0) then
  begin
    BH_CheckWaterFish();
  end;
end;

{$ENDIF}
