{$IFNDEF BuildHelperTerrain}
{$DEFINE BuildHelperTerrain}

{$INCLUDE BuildHelperGlobal.script}

{$EVENT evtTick:BH_OnTickTerrain}
{$EVENT evtRoadBuilt:BH_OnRoadBuiltTerrain}
{$EVENT evtHousePlanPlacedEx:BH_OnHousePlanPlacedExTerrain}
{$EVENT evtHousePlanRemovedEx:BH_OnHousePlanRemovedExTerrain}
{$EVENT evtPlanRoadPlaced:BH_OnPlanRoadPlacedTerrain}
{$EVENT evtPlanRoadRemoved:BH_OnPlanRoadRemovedTerrain}
{$EVENT evtHouseBuilt:BH_OnHouseBuiltTerrain}
{$EVENT evtHouseDestroyed:BH_OnHouseDestroyedTerrain}
{$EVENT evtMissionStart:BH_OnMissionStartTerrain}

//----------------------------------------------------------------------------------------------------------------------------------------------------
//IRON AND GOLD MINES.
//----------------------------------------------------------------------------------------------------------------------------------------------------

function BH_IsMapPoint(x,y: integer): boolean;
begin
  result := (x > 0) and (y > 0) and (x < S.MapWidth) and (y < S.MapHeight);
end;

function BH_GetDistance(first, second: TKMPoint): Single;
begin
  result := U.Power(((first.X - second.X)*(first.X - second.X) + (first.Y - second.Y)*(first.Y - second.Y)), 0.5);
end;

function BH_SafeMapTileIsIron(x,y: integer): boolean;
begin

  result := false;
  if (BH_IsMapPoint(x,y)) then
  begin
    result := S.MapTileIsIron(x, y);
  end;
end;

function BH_SafeMapTileIsGold(x,y: integer): boolean;
begin

  result := false;
  if (BH_IsMapPoint(x,y)) then
  begin
    result := S.MapTileIsGold(x, y);
  end;
end;

function BH_IsIronTile(x,y: integer): boolean;
begin
  result := BH_SafeMapTileIsIron(x, y-1) or BH_SafeMapTileIsIron(x-1, y-1) or BH_SafeMapTileIsIron(x+1, y-1) or BH_SafeMapTileIsIron(x-2, y-1) or BH_SafeMapTileIsIron(x+2, y-1);
end;

function BH_IsGoldTile(x,y: integer): boolean;
begin
  result := BH_SafeMapTileIsGold(x, y-1) or BH_SafeMapTileIsGold(x-1, y-1) or BH_SafeMapTileIsGold(x+1, y-1) or BH_SafeMapTileIsGold(x-2, y-1);
end;

function BH_SafeHouseAt(x, y: integer): integer;
begin
  result := -1;

  if (BH_IsMapPoint(x,y)) then
  begin
    result := S.HouseAt(x,y);
  end;
end;

function BH_CanBuildIronMine(x, y: integer): boolean;
begin

  result := (BH_SafeHouseAt(x-2,y-1) = -1) and (BH_SafeHouseAt(x-2,y  ) = -1) and (BH_SafeHouseAt(x-2,y+1) = -1) and
            (BH_SafeHouseAt(x-1,y+1) = -1) and (BH_SafeHouseAt(x  ,y+1) = -1) and (BH_SafeHouseAt(x+1,y+1) = -1) and
            (BH_SafeHouseAt(x+2,y+1) = -1) and (BH_SafeHouseAt(x+2,y  ) = -1) and (BH_SafeHouseAt(x+2,y-1) = -1);
end;

function BH_CanBuildGoldMine(x, y: integer): boolean;
begin

  result := (BH_SafeHouseAt(x-2,y-1) = -1) and (BH_SafeHouseAt(x-2,y  ) = -1) and (BH_SafeHouseAt(x-2,y+1) = -1) and
            (BH_SafeHouseAt(x-1,y+1) = -1) and (BH_SafeHouseAt(x  ,y+1) = -1) and
            (BH_SafeHouseAt(x+1,y+1) = -1) and (BH_SafeHouseAt(x+1,y  ) = -1) and (BH_SafeHouseAt(x+1,y-1) = -1);
end;

function BH_ExistsPoint(points: array of TKMPoint; x,y: integer): boolean;
var
  i: integer;

begin

  result := false;

  for i:=0 to High(points) do
  begin

    if ((points[i].X = x) and (points[i].Y = y)) then
    begin

      result := true;
      exit;
    end;
  end;
end;

function BH_ReverseExistPoint(points: array of TKMPoint; x,y: integer): boolean;
var
  i: integer;

begin

  result := false;

  for i:=0 to High(points) do
  begin

    if ((points[High(points)-i].X = x) and (points[High(points)-i].Y = y)) then
    begin

      result := true;
      exit;
    end;
  end;
end;

function BH_RemovePoint(points: array of TKMPoint; x,y: integer): array of TKMPoint;
var
  i: integer;

begin

  result := points;

  for i:=0 to High(result) do
  begin
    if ((result[i].X = x) and (result[i].Y = y)) then
    begin

      result[i].X := result[High(result)].X;
      result[i].Y := result[High(result)].Y;

      SetLength(result, Length(result) - 1);
      exit;
    end;
  end;
end;

function BH_AddPoint(points: array of TKMPoint; x,y: integer): array of TKMPoint;
begin
  result := points;
  SetLength(result, Length(result) + 1);
  result[High(result)].X := x;
  result[High(result)].Y := y;
end;

function BH_AddUniquePoint(points: array of TKMPoint; x,y: integer): array of TKMPoint;
begin

  if (not BH_ExistsPoint(points, x, y)) then
  begin
    result := BH_AddPoint(points, x, y);
  end else
  begin
    result := points;
  end;

end;

function BH_AreConflictingPoints(conflicts: array of array of TKMPoint; x1, y1, x2, y2: integer): boolean;
var
  i: integer;
  j: integer;
  firstExist: boolean;
  secondExist: boolean;

begin

  result := false;
  for i := 0 to High(conflicts) do
  begin

    firstExist := false;
    secondExist := false;

    for j := 0 to High(conflicts[i]) do
    begin

      if ((conflicts[i][j].X = x1) and (conflicts[i][j].Y = y1)) then
      begin
        firstExist:= true;
      end;
      if ((conflicts[i][j].X = x2) and (conflicts[i][j].Y = y2)) then
      begin
        secondExist:= true;
      end;

    end;

    if (firstExist and secondExist) then
    begin
      result := true;
      exit;
    end;
  end;
end;

function BH_ExistsConflictingPoint(conflicts: array of array of TKMPoint; points: array of TKMPoint; x, y: integer): boolean;
var
  i: integer;

begin

  result := false;
  for i:= 0 to High(points) do
  begin

    if(BH_AreConflictingPoints(conflicts, points[i].X, points[i].Y, x, y)) then
    begin

      result := true;
      exit;
    end;
  end;

end;

function BH_FillConflictingPoints(conflicts: array of array of TKMPoint; points: array of TKMPoint; x, y: integer): array of TKMPoint;
var
  i: integer;
  j: integer;
  index: integer;

begin

  result := points;

  for i := 0 to High(conflicts) do
  begin

    if (not BH_ExistsPoint(conflicts[i], x, y)) then
    begin
      continue;
    end;

    index:= Length(result);
    SetLength(result, Length(result) + Length(conflicts[i]));

    for j := 0 to High(conflicts[i]) do
    begin

      result[index].X := conflicts[i][j].X;
      result[index].Y := conflicts[i][j].Y;
      Inc(index);

    end;
  end;
end;

function BH_GetPlayerPossibleIronMines(player: BH_Player): integer;
var
  i: integer;
  x: integer;
  y: integer;
  houseId: integer;
  conflictPoints: array of TKMPoint;
  usedPoints: array of TKMPoint;
begin

  for i:=0 to High(player.CloseIronMinesLocations) do
  begin

    x := player.CloseIronMinesLocations[i].X;
    y := player.CloseIronMinesLocations[i].Y;

    houseId := S.HouseAt(x,y);

    if ((houseId > 0) and (not S.HouseIsComplete(houseId)) and (S.HouseOwner(houseId) = player.Id)) then
    begin

      if (BH_ExistsPoint(conflictPoints, x, y)) then
      begin
        continue;
      end;

      conflictPoints := BH_FillConflictingPoints(BH_IronMinesConflicts, conflictPoints, x,y);
      usedPoints := BH_AddPoint(usedPoints, x,y);

    end else
    if ((houseId = -1) and BH_CanBuildIronMine(x,y)) then
    begin

      if (BH_ExistsPoint(conflictPoints, x, y)) then
      begin
        continue;
      end;

      conflictPoints := BH_FillConflictingPoints(BH_IronMinesConflicts, conflictPoints, x,y);
      usedPoints := BH_AddPoint(usedPoints, x,y);


    end;
  end;

  result := Length(usedPoints);
end;

function BH_GetPlayerPossibleGoldMines(player: BH_Player): integer;
var

  i: integer;
  x: integer;
  y: integer;
  houseId: integer;
  conflictPoints: array of TKMPoint;
  usedPoints: array of TKMPoint;
begin

  //TODO. Think how unite this and BH_GetPlayerPossibleIronMines.

  for i:=0 to High(player.CloseGoldMinesLocations) do
  begin

    x := player.CloseGoldMinesLocations[i].X;
    y := player.CloseGoldMinesLocations[i].Y;

    houseId := S.HouseAt(x,y);

    if ((houseId > 0) and (not S.HouseIsComplete(houseId)) and (S.HouseOwner(houseId) = player.Id)) then
    begin

      if (BH_ExistsPoint(conflictPoints, x, y)) then
      begin
        continue;
      end;

      conflictPoints := BH_FillConflictingPoints(BH_GoldMinesConflicts, conflictPoints, x,y);
      usedPoints := BH_AddPoint(usedPoints, x,y);

    end else
    if ((houseId = -1) and BH_CanBuildGoldMine(x,y)) then
    begin

      if (BH_ExistsPoint(conflictPoints, x, y)) then
      begin
        continue;
      end;

      conflictPoints := BH_FillConflictingPoints(BH_GoldMinesConflicts, conflictPoints, x,y);
      usedPoints := BH_AddPoint(usedPoints, x,y);

    end;
  end;

  result := Length(usedPoints);
end;

procedure BH_TryToAddIronConflicts(x, y, tilesInRow: integer);
var
  i: integer;
  toTile: integer;
  index: integer;
  xLocations: array of integer;

begin

  if (tilesInRow < 4) then
  begin
    exit;
  end;

  repeat

    xLocations := [];
    toTile := U.IfThenI((tilesInRow - 3) > 3, x - tilesInRow + 1 + 3, x - 2);

    for i:= x - tilesInRow + 1 to toTile do
    begin
      SetLength(xLocations, Length(xLocations) + 1);
      xLocations[High(xLocations)] := i;
    end;

    SetLength(BH_IronMinesConflicts, Length(BH_IronMinesConflicts) + 1);
    index := High(BH_IronMinesConflicts);
    SetLength(BH_IronMinesConflicts[index], Length(xLocations));

    for i:= 0 to High(xLocations) do
    begin

      BH_IronMinesConflicts[index][i].X := xLocations[i];
      BH_IronMinesConflicts[index][i].Y := y;
    end;

    Dec(tilesInRow);
  until (tilesInRow < 6);
end;

procedure BH_TryToAddGoldConflicts(x, y, tilesInRow: integer);
var
  i: integer;
  toTile: integer;
  index: integer;
  xLocations: array of integer;

begin

  if (tilesInRow < 3) then
  begin
    exit;
  end;

  repeat

    xLocations := [];
    toTile := U.IfThenI((tilesInRow - 2) > 2, x - tilesInRow + 1 + 2, x - 1);

    for i:= x - tilesInRow + 1 to toTile do
    begin
      SetLength(xLocations, Length(xLocations) + 1);
      xLocations[High(xLocations)] := i;
    end;

    SetLength(BH_GoldMinesConflicts, Length(BH_GoldMinesConflicts) + 1);
    index := High(BH_GoldMinesConflicts);
    SetLength(BH_GoldMinesConflicts[index], Length(xLocations));

    for i:= 0 to High(xLocations) do
    begin

      BH_GoldMinesConflicts[index][i].X := xLocations[i];
      BH_GoldMinesConflicts[index][i].Y := y;
    end;

    Dec(tilesInRow);
  until (tilesInRow < 4);
end;

procedure BH_UpdatePlayerMinesInfo(playerId: integer; location :TKMPoint);
var
  i: integer;
  index : integer;

begin

  index := BH_FindPlayerIndex(playerId);

  if (index = -1) then
  begin
    exit;
  end;

  for i:= 0 to High(BH_IronMinesLocations) do
  begin

    if (BH_GetDistance(location, BH_IronMinesLocations[i]) < BH_MinesDistance) then
    begin

      BH_Players[index].CloseIronMinesLocations := BH_AddUniquePoint(BH_Players[index].CloseIronMinesLocations, BH_IronMinesLocations[i].X, BH_IronMinesLocations[i].Y);

    end;
  end;

  for i:= 0 to High(BH_GoldMinesLocations) do
  begin

    if (BH_GetDistance(location, BH_GoldMinesLocations[i]) < BH_MinesDistance) then
    begin

      BH_Players[index].CloseGoldMinesLocations := BH_AddUniquePoint(BH_Players[index].CloseGoldMinesLocations, BH_GoldMinesLocations[i].X, BH_GoldMinesLocations[i].Y);

    end;
  end;

end;

//----------------------------------------------------------------------------------------------------------------------------------------------------
//ROADS.
//----------------------------------------------------------------------------------------------------------------------------------------------------

procedure BH_InitMapTile(x, y: integer);
var
  unitId: integer;
begin

  if (S.IsRoadAt(-1,x,y)) then
  begin

    BH_MapTilesInfo[x][y].RoadTileType := RTT_Road;
    BH_MapTilesInfo[x][y].RoadConnectionType := RCT_Strong;
  end;

  unitId := S.UnitAt(x,y);

  if ((unitId <> -1) and (S.UnitTypeEx(unitId) = utFish)) then
  begin

  end;

end;

function BH_SaveGetRoadConnectionType(x,y: integer): BH_RoadConnectionType;
begin

  result := RCT_Null;
  if (BH_IsMapPoint(x,y)) then
  begin
    result := BH_MapTilesInfo[x][y].RoadConnectionType;
  end;
end;

function BH_GetBestConnection(first,second: BH_RoadConnectionType): BH_RoadConnectionType;
begin

  if (first = RCT_Strong) then
  begin
    result := first;
    exit;
  end;

  if ((first = RCT_Weak) and (second = RCT_Null)) then
  begin
    result := first;
    exit;
  end;

  result := second;
end;

function BH_GetBestNeighborConnection(x,y: integer): BH_RoadConnectionType;
begin

  result := BH_SaveGetRoadConnectionType(x-1,y);

  if (result = RCT_Strong) then
    exit;

  result := BH_GetBestConnection(result, BH_SaveGetRoadConnectionType(x+1,y));

  if (result = RCT_Strong) then
    exit;

  result := BH_GetBestConnection(result, BH_SaveGetRoadConnectionType(x,y-1));

  if (result = RCT_Strong) then
    exit;

  result := BH_GetBestConnection(result, BH_SaveGetRoadConnectionType(x,y+1));

end;

procedure BH_ConnectRoads(x,y: integer; connectionType: BH_RoadConnectionType);
begin

  BH_MapTilesInfo[x][y].LastUsedPointHash := 0;

  if ((not BH_IsMapPoint(x,y)) or (BH_MapTilesInfo[x][y].RoadTileType = RTT_Null)) then
  begin
    exit;
  end;

  if (BH_MapTilesInfo[x][y].RoadConnectionType = RCT_Strong) then
  begin
    exit;
  end;

  if (BH_MapTilesInfo[x][y].RoadConnectionType = connectionType) then
  begin
    exit;
  end;

  if ((connectionType = RCT_Strong) and (BH_MapTilesInfo[x][y].RoadTileType <> RTT_Road)) then
  begin
    exit;
  end;

  BH_MapTilesInfo[x][y].RoadConnectionType := connectionType;

  BH_ConnectRoads(x  , y-1, connectionType);
  BH_ConnectRoads(x  , y+1, connectionType);
  BH_ConnectRoads(x-1, y  , connectionType);
  BH_ConnectRoads(x+1, y  , connectionType);

  //A.Log('Was Connected : ' + IntToStr(x) + ';' + IntToStr(y) + ' ' + IntToStr(BH_MapTilesInfo[x][y].RoadConnectionType));
end;

function BH_CheckConnection(hash: integer; x,y: integer): boolean;
begin

  result := false;

  if ((not BH_IsMapPoint(x,y)) or (BH_MapTilesInfo[x][y].RoadTileType = RTT_Null)) then
  begin
    exit;
  end;

  if (BH_MapTilesInfo[x][y].RoadConnectionType = RCT_Strong) then
  begin
    result := true;
    exit;
  end;

  if (BH_MapTilesInfo[x][y].LastUsedPointHash = hash) then
  begin
    exit;
  end;

  BH_MapTilesInfo[x][y].LastUsedPointHash := hash;

  //Rare case if you are building normaly. But if you make too many roads this will crush game.
  //if (Length(usedPoints) > 13) then
  //begin
  //  result := false;
  //  exit;
  //end;

  if (BH_CheckConnection(hash, x  , y-1)) then
  begin
    result := true;
    exit;
  end;

  if (BH_CheckConnection(hash, x  , y+1)) then
  begin
    result := true;
    exit;
  end;

  if (BH_CheckConnection(hash, x-1, y  )) then
  begin
    result := true;
    exit;
  end;

  if (BH_CheckConnection(hash, x+1, y  )) then
  begin
    result := true;
    exit;
  end;
end;

procedure BH_FillMapInfo();
var
  x: integer;
  y: integer;
  tileType: integer;
  ironTilesInRow: integer;
  goldTilesInRow: integer;
  //fishTiles: array of integer;
begin

  SetLength(BH_MapTilesInfo, S.MapWidth + 1);

  for y:=1 to S.MapWidth - 1 do
  begin
    SetLength(BH_MapTilesInfo[y], S.MapHeight + 1);
  end;

  for y:=1 to S.MapHeight - 1 do
  begin

    BH_TryToAddIronConflicts(x,y,ironTilesInRow);
    ironTilesInRow := 0;

    BH_TryToAddGoldConflicts(x,y-1,goldTilesInRow);
    goldTilesInRow := 0;

    for x:=1 to S.MapWidth - 1 do
    begin

      BH_InitMapTile(x,y);

      tileType := S.MapTileType(x,y);

      if ((tileType = 167) or (tileType = 168)) then
      begin

        BH_TryToAddGoldConflicts(x,y,goldTilesInRow);
        goldTilesInRow := 0;

        if ((S.MapTileRotation(x,y) <> 0) or (not BH_IsIronTile(x,y))) then
        begin

          BH_TryToAddIronConflicts(x,y,ironTilesInRow);
          ironTilesInRow := 0;

          continue;
        end;

        Inc(ironTilesInRow);

        if (ironTilesInRow >= 3) then
        begin

          BH_IronMinesLocations := BH_AddPoint(BH_IronMinesLocations, x-1, y);
        end;


      end else
      if ((tileType = 172) or (tileType = 175))  then
      begin

        BH_TryToAddIronConflicts(x,y,ironTilesInRow);
        ironTilesInRow := 0;

        if ((S.MapTileRotation(x,y) <> 0) or (not BH_IsGoldTile(x,y))) then
        begin
          BH_TryToAddGoldConflicts(x,y,goldTilesInRow);
          goldTilesInRow := 0;
          continue;
        end;

        Inc(goldTilesInRow);

        if (goldTilesInRow >= 2) then
        begin

          BH_GoldMinesLocations := BH_AddPoint(BH_GoldMinesLocations, x, y);
        end;
      end else
      begin

        BH_TryToAddIronConflicts(x,y,ironTilesInRow);
        ironTilesInRow := 0;

        BH_TryToAddGoldConflicts(x,y,goldTilesInRow);
        goldTilesInRow := 0;
      end;

    end;
  end;
end;

//----------------------------------------------------------------------------------------------------------------------------------------------------
//FISH.
//----------------------------------------------------------------------------------------------------------------------------------------------------

function BH_IsPossibleToMakeFishermans(player: BH_Player):boolean;
begin
  result := true;
end;

//----------------------------------------------------------------------------------------------------------------------------------------------------
//BH_BuildingPlanCollection.
//----------------------------------------------------------------------------------------------------------------------------------------------------

function BH_FindBuildingPlanInCollectionIndex(buildingPlans: array of BH_BuildingPlanCollection; buildingType: TKMHouseType): integer;
var
  i: integer;
begin

  result:= -1;
  for i:=0 to High(buildingPlans) do
  begin
    if (buildingPlans[i].BuildingType = buildingType) then
    begin
      result:= i;
      exit;
    end;
  end;
end;

function BH_AddBuildingPlanTypeToCollection(buildingPlans: array of BH_BuildingPlanCollection; buildingType: TKMHouseType): array of BH_BuildingPlanCollection;
var
  index: integer;
begin

  result := buildingPlans;
  index:= BH_FindBuildingPlanInCollectionIndex(result, buildingType);

  if (index <> -1)then
  begin
    exit;
  end;

  setLength(result, Length(result) + 1);
  result[High(result)].BuildingType := buildingType;
end;


procedure BH_AddPlayerBuildingPlan(playerId: integer; buildingType: TKMHouseType; x,y: integer);
var
  playerIndex: integer;
  buildingIndex: integer;
  count: integer;
begin

  playerIndex:= BH_FindPlayerIndex(playerId);

  if (playerIndex = -1) then
  begin
    exit;
  end;

  buildingIndex := BH_FindBuildingPlanInCollectionIndex(BH_Players[playerIndex].BuildingPlans, buildingType);

  if (buildingIndex = -1) then
  begin
    BH_Players[playerIndex].BuildingPlans := BH_AddBuildingPlanTypeToCollection(BH_Players[playerIndex].BuildingPlans, buildingType);
    buildingIndex := High(BH_Players[playerIndex].BuildingPlans);
  end;

  count := Length(BH_Players[playerIndex].BuildingPlans[buildingIndex].Locations);
  setLength(BH_Players[playerIndex].BuildingPlans[buildingIndex].Locations, count + 1);
  BH_Players[playerIndex].BuildingPlans[buildingIndex].Locations[count].X := x;
  BH_Players[playerIndex].BuildingPlans[buildingIndex].Locations[count].Y := y;
end;

procedure BH_RemovePlayerBuildingPlan(playerId: integer; buildingType: TKMHouseType; x,y: integer);
var
  playerIndex: integer;
  buildingIndex: integer;
begin

  playerIndex:= BH_FindPlayerIndex(playerId);

  if (playerIndex = -1) then
  begin
    exit;
  end;

  buildingIndex := BH_FindBuildingPlanInCollectionIndex(BH_Players[playerIndex].BuildingPlans, buildingType);

  if (buildingIndex = -1) then
  begin
    exit;
  end;

  if (BH_ExistsPoint(BH_Players[playerIndex].BuildingPlans[buildingIndex].Locations, x,y)) then
  begin
    BH_Players[playerIndex].BuildingPlans[buildingIndex].Locations := BH_RemovePoint(BH_Players[playerIndex].BuildingPlans[buildingIndex].Locations, x, y);
  end;
end;

//----------------------------------------------------------------------------------------------------------------------------------------------------
//EVENTS.
//----------------------------------------------------------------------------------------------------------------------------------------------------

procedure BH_OnRoadBuiltTerrain(playerId: integer; x, y: integer);
var
  connectionType: BH_RoadConnectionType;

begin

  BH_MapTilesInfo[x][y].RoadTileType := RTT_Road;

  connectionType := BH_GetBestNeighborConnection(x,y);

  if (connectionType <> RCT_Null) then
  begin
    BH_ConnectRoads(x,y, connectionType);
  end;
end;

procedure BH_OnPlanRoadPlacedTerrain(playerId: integer; x, y: integer);
var
  connectionType: BH_RoadConnectionType;

begin

  BH_MapTilesInfo[x][y].RoadTileType := RTT_RoadPlan;

  connectionType := BH_GetBestNeighborConnection(x,y);

  //A.Log('Trying to connect : ' + IntToStr(x) + ';' + IntToStr(y));

  if (connectionType <> RCT_Null) then
  begin

    //A.Log('Connecting : ' + IntToStr(x) + ';' + IntToStr(y) + ' ' + IntToStr(connectionType));
    BH_ConnectRoads(x,y, RCT_Weak);
  end;

end;

procedure BH_OnPlanRoadRemovedTerrain(playerId: integer; x, y: integer);
begin

  BH_MapTilesInfo[x][y].RoadTileType := RTT_Null;
  BH_MapTilesInfo[x][y].RoadConnectionType := RCT_Null;

  if (not BH_CheckConnection(x*y, x  ,y-1)) then
  begin
    BH_ConnectRoads(x,y-1, RCT_Null);
  end;

  if (not BH_CheckConnection(x*y, x  ,y+1)) then
  begin
    BH_ConnectRoads(x,y+1, RCT_Null);
  end;

  if (not BH_CheckConnection(x*y, x-1,y  )) then
  begin
    BH_ConnectRoads(x-1,y, RCT_Null);
  end;

  if (not BH_CheckConnection(x*y, x+1,y  )) then
  begin
    BH_ConnectRoads(x+1,y, RCT_Null);
  end;
end;

procedure BH_OnHousePlanPlacedExTerrain(playerId: integer; x, y: integer; houseType: TKMHouseType);
begin
  BH_AddPlayerBuildingPlan(playerId, houseType, x,y);
end;

procedure BH_OnHousePlanRemovedExTerrain(playerId: integer; x, y: integer; houseType: TKMHouseType);
begin
  BH_RemovePlayerBuildingPlan(playerId, houseType, x,y);
end;

procedure BH_OnHouseBuiltTerrain(aHouse: integer);
var
  ownerId: integer;
  houseType: TKMHouseType;
  location: TKMPoint;

begin
  ownerId := S.HouseOwner(aHouse);
  BH_UpdatePlayerMinesInfo(ownerId, S.HousePosition(aHouse));

  houseType := S.HouseTypeEx(aHouse);
  location := S.HousePosition(aHouse);

  BH_RemovePlayerBuildingPlan(ownerId, houseType, location.X,location.Y);

  if (houseType = htGoldMine) then
  begin

  BH_GoldMinesLocations := BH_RemovePoint(BH_GoldMinesLocations, location.X, location.Y);
  end else
  if (houseType = htIronMine) then
  begin

    BH_IronMinesLocations := BH_RemovePoint(BH_IronMinesLocations, location.X, location.Y);
  end;
end;

procedure BH_OnHouseDestroyedTerrain(aHouse: integer; aDestroyerIndex: integer);
var
  ownerId: integer;
  houseType: TKMHouseType;
  location: TKMPoint;

begin
  ownerId := S.HouseOwner(aHouse);
  houseType := S.HouseTypeEx(aHouse);
  location := S.HousePosition(aHouse);

  BH_RemovePlayerBuildingPlan(ownerId, houseType, location.X,location.Y);

  if (houseType = htGoldMine) then
  begin

    if (S.HouseCanReachResources(aHouse)) then
    begin
      BH_GoldMinesLocations := BH_AddPoint(BH_GoldMinesLocations, location.X, location.Y);
    end;

    //TODO. else remove from all players and remove from conflicts.

  end else
  if (houseType = htIronMine) then
  begin

    if (S.HouseCanReachResources(aHouse)) then
    begin
      BH_IronMinesLocations := BH_AddPoint(BH_IronMinesLocations, location.X, location.Y);
    end;

    //TODO. else remove from all players and remove from conflicts.

  end;

end;

procedure BH_OnMissionStartTerrain;
begin
  BH_FillMapInfo();
end;

procedure BH_OnTickTerrain;
begin

  if (BH_NeedToUpdate and ((S.GameTime - 1) mod 2 = 0)) then
  begin
    BH_Players[BH_MinesUpdateIndex].PossibleIronMinesCount := BH_GetPlayerPossibleIronMines(BH_Players[BH_MinesUpdateIndex]);
    BH_Players[BH_MinesUpdateIndex].PossibleGoldMinesCount := BH_GetPlayerPossibleGoldMines(BH_Players[BH_MinesUpdateIndex]);

    Inc(BH_MinesUpdateIndex);

    if BH_MinesUpdateIndex > High(BH_Players) then
    begin
      BH_MinesUpdateIndex := 0;
      BH_NeedToUpdate := false;
    end;
  end;

  if ((S.GameTime - 1) mod (10 * BH_Seconds) = 0) then
  begin
    BH_NeedToUpdate:= true;
  end;
end;

{$ENDIF}
