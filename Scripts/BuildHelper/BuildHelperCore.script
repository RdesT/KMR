{$IFNDEF BuildHelperCore}
{$DEFINE BuildHelperCore}

{$EVENT evtTick:BH_OnTickCore}
{$EVENT evtHouseBuilt:BH_OnHouseBuiltCore}
{$EVENT evtHouseDestroyed:BH_OnHouseDestroyedCore}
{$EVENT evtHousePlanPlacedEx:BH_OnHousePlanPlacedExCore}
{$EVENT evtHousePlanRemovedEx:BH_OnHousePlanRemovedExCore}
{$EVENT evtPlanRoadPlaced:BH_OnPlanRoadPlacedCore}
{$EVENT evtPlanRoadRemoved:BH_OnPlanRoadRemovedCore}
{$EVENT evtMissionStart:BH_OnMissionStartCore}
{$EVENT evtRoadBuilt:BH_OnRoadBuiltCore}



type
	BH_FoodAmountEnum = (FA_VERY_LOW, FA_LOW, FA_OK, FA_HIGH, FA_VERY_HIGH);

type
  BH_BuildingStrategy = (BS_Null, BS_Default_60, BS_IronStoring_60, BS_LeatherOnly_60, BS_IronOnly_60, BS_IronRush_60, BS_DoubleStable_60, BS_IronAndGold_60, BS_Gold60, BS_Default35);

type
  BH_RoadTileType = (RTT_Null, RTT_Road, RTT_RoadPlan);

type
  BH_RoadConnectionType = (RCT_Null, RCT_Weak, RCT_Strong);

type
  BH_Color = (Color_White, Color_Green, Color_Yellow, Color_Red, Color_Blue);

type BH_MapTileInfo =
record
  //PlayerId: integer;
  RoadTileType: BH_RoadTileType;
  RoadConnectionType: BH_RoadConnectionType;
  LastUsedPointHash: integer;
end;

type BH_BuildingCollection =
record
  BuildingType: TKMHouseType;
  Ids: TIntegerArray;
end;

type BH_BuildingPlanCollection =
record
  BuildingType: TKMHouseType;
  Locations: array of TKMPoint;
end;

type BH_BuildingsCountInfo =
record
  School: integer;
  Inn: integer;
  Quarry: integer;
  Woodcutters: integer;
  Sawmill: integer;
  Farm: integer;
  Mill: integer;
  Bakery: integer;
  Swine: integer;
  Butchers: integer;
  Vineyard: integer;
  Goldmine: integer;
  Coalmine: integer;
  Metallurgists: integer;
  Weaponworkshop: integer;
  Tannery: integer;
  Armorworkshop: integer;
  Stables: integer;
  Ironmine: integer;
  Ironsmithy: integer;
  Weaponsmithy: integer;
  Armorsmithy: integer;
  Barracks: integer;
  Store: integer;
  WatchTower: integer;
  Fishermans: integer;
  Market: integer;
  TownHall: integer;
end;

type BH_CitizensCountInfo =
record
  Serf: integer;
  Woodcutter: integer;
  Miner: integer;
  AnimalBreeder: integer;
  Farmer: integer;
  Carpenter: integer;
  Baker: integer;
  Butcher: integer;
  Fisher: integer;
  Builder: integer;
  Stonemason: integer;
  Smith: integer;
  Metallurgist: integer;
  Recruit: integer;
end;

type BH_BuildingInfo =
record
  BuildingType: TKMHouseType;
  Count: integer;
end;

type BH_Advice =
record
  Id: string;
  ShowTime: integer;
  OneTimeAdvice: boolean;
  Color: BH_Color;
end;

type BH_Player =
record
  Id: integer;
  Advices: array of BH_Advice;
  Buildings: array of BH_BuildingCollection;
  BuildingPlans: array of BH_BuildingPlanCollection;
  IsSlowBuildOrder: boolean;
  StartingFoodAmount: BH_FoodAmountEnum;
  BuildingStrategy: BH_BuildingStrategy;
  FirstFarmTime: integer;

  PossibleIronMinesCount: integer;
  PossibleGoldMinesCount: integer;

  CloseIronMinesLocations: array of TKMPoint;
  CloseGoldMinesLocations: array of TKMPoint;
end;

const BH_Seconds = 10;
const BH_Minutes = 600;

const BH_Wine = 0.3;
const BH_Bread = 0.4;
const BH_Fish = 0.5;
const BH_Sausage = 0.6;

const BH_MinesDistance = 21;

var
  BH_Players: array of BH_Player;

  BH_MapTilesInfo: array of array of BH_MapTileInfo;

  BH_IronMinesLocations: array of TKMPoint;
  BH_GoldMinesLocations: array of TKMPoint;

  BH_IronMinesConflicts: array of array of TKMPoint;
  BH_GoldMinesConflicts: array of array of TKMPoint;

  BH_GlobalBuildingStrategy: BH_BuildingStrategy;

  BH_NeedToUpdate: boolean;
  BH_MinesUpdateIndex: integer;

//----------------------------------------------------------------------------------------------------------------------------------------------------
//ARRAYS RELATED FUNCTIONS.
//----------------------------------------------------------------------------------------------------------------------------------------------------

function BH_FindElementIndex(arr: TIntegerArray; element: integer): integer;
var
  i: integer;
begin

  for i:= 0 to High(arr) do
  begin
    if (arr[i] = element) then
    begin
      result := i;
      exit;
    end;

  end;

  result := -1;
end;

//BH_Player

function BH_FindPlayerIndex(playerId: integer): integer;
var
  i: integer;
begin

  result := -1;
  for i:= 0 to High(BH_Players) do
  begin
    if (BH_Players[i].Id = playerId) then
    begin
      result:= i;
      exit;
    end;
  end;
end;

procedure BH_AddPlayer(playerId: integer);
begin

  setLength(BH_Players, Length(BH_Players) + 1);
  BH_Players[High(BH_Players)].Id := playerId;
end;

//BH_BuildingCollection

function BH_FindBuildingInCollectionIndex(buildings: array of BH_BuildingCollection; buildingType: TKMHouseType): integer;
var
  i: integer;
begin

  result:= -1;
  for i:=0 to High(buildings) do
  begin
    if (buildings[i].BuildingType = buildingType) then
    begin
      result:= i;
      exit;
    end;
  end;
end;

function BH_AddBuildingTypeToCollection(buildings: array of BH_BuildingCollection; buildingType: TKMHouseType): array of BH_BuildingCollection;
var
  index: integer;
begin

  result := buildings;
  index:= BH_FindBuildingInCollectionIndex(result, buildingType);

  if (index <> -1)then
  begin
    exit;
  end;

  setLength(result, Length(result) + 1);
  result[High(result)].BuildingType := buildingType;
end;

//BH_BuildingPlanCollection

function BH_FindBuildingPlanInCollectionIndex(buildingPlans: array of BH_BuildingPlanCollection; buildingType: TKMHouseType): integer;
var
  i: integer;
begin

  result:= -1;
  for i:=0 to High(buildingPlans) do
  begin
    if (buildingPlans[i].BuildingType = buildingType) then
    begin
      result:= i;
      exit;
    end;
  end;
end;

function BH_AddBuildingPlanTypeToCollection(buildingPlans: array of BH_BuildingPlanCollection; buildingType: TKMHouseType): array of BH_BuildingPlanCollection;
var
  index: integer;
begin

  result := buildingPlans;
  index:= BH_FindBuildingPlanInCollectionIndex(result, buildingType);

  if (index <> -1)then
  begin
    exit;
  end;

  setLength(result, Length(result) + 1);
  result[High(result)].BuildingType := buildingType;
end;

//BH_BuildingInfo

function BH_FindBuildingInfoIndex(buildingsInfo: array of BH_BuildingInfo; buildingType: TKMHouseType): integer;
var
  i: integer;
begin

  result:= -1;
  for i:=0 to High(buildingsInfo) do
  begin
    if (buildingsInfo[i].BuildingType = buildingType) then
    begin
      result:= i;
      exit;
    end;
  end;
end;

function BH_GetAllBuildingsCount(buildingsInfo: array of BH_BuildingInfo): integer;
var
  i: integer;

begin
  for i:=0 to High(buildingsInfo) do
  begin
    result := result + buildingsInfo[i].Count;
  end;
end;

function BH_GetBuildingTypeCount(buildingsInfo: array of BH_BuildingInfo; buildingType: TKMHouseType): integer;
var
  i: integer;

begin

  result := 0;
  for i:=0 to High(buildingsInfo) do
  begin
    if (buildingsInfo[i].BuildingType = buildingType) then
    begin
      result:= buildingsInfo[i].Count;
      exit;
    end;
  end;
end;

function BH_AddBuildingInfo(buildings: array of BH_BuildingInfo; buildingType: TKMHouseType) :array of BH_BuildingInfo;
var
  index: integer;
begin

  result := buildings;
  index:= BH_FindBuildingInfoIndex(result, buildingType);

  if (index = -1) then
  begin
    setLength(result, Length(result) + 1);
    result[High(result)].BuildingType := buildingType;
    index := High(result);
  end;

  result[index].Count := result[index].Count + 1;
end;

function BH_AddMultipleBuildingInfo(buildings: array of BH_BuildingInfo; buildingType: TKMHouseType; count : integer; maxBuildingsCount: integer) :array of BH_BuildingInfo;
var
  i: integer;

begin

  if (count <= 0) then
  begin
    exit;
  end;

  result:= buildings;

  for i := 1 to count do
  begin
    if (BH_GetAllBuildingsCount(result) >= maxBuildingsCount) then
    begin
      exit;
    end;

    result := BH_AddBuildingInfo(result, buildingType);
  end;
end;

function BH_UniteBuildingInfos(buildings: array of BH_BuildingInfo; addingBuildings: array of BH_BuildingInfo) : array of BH_BuildingInfo;
var
  i: integer;
  index : integer;

begin

  result := buildings;

  for i:= 0 to High(buildings) do
  begin
    setLength(result, Length(result) + 1);
    result[High(result)].BuildingType := buildings[i].BuildingType;
    result[High(result)].Count := buildings[i].Count;
  end;

  for i:= 0 to High(addingBuildings) do
  begin
    index := BH_FindBuildingInfoIndex(result, addingBuildings[i].BuildingType);

    if (index = -1) then
    begin
      setLength(result, Length(result) + 1);
      result[High(result)].BuildingType := addingBuildings[i].BuildingType;
      result[High(result)].Count := addingBuildings[i].Count;
      index := High(result);
    end else
    begin
      result[index].Count := result[index].Count + addingBuildings[i].Count;
    end;
  end;
end;

function BH_BuildingCollectionToBuildingInfo(buildings: array of BH_BuildingCollection) : array of BH_BuildingInfo;
var
  i: integer;

begin

  for i:= 0 to High(buildings) do
  begin
    setLength(result, Length(result) + 1);
    result[High(result)].BuildingType := buildings[i].BuildingType;
    result[High(result)].Count := Length(buildings[i].Ids);
  end;

end;

//BH_Advise

function BH_FindTipsIndex(tips: array of BH_Advice; adviceId: string): integer;
var
  i: integer;
begin

  result:= -1;
  for i:=0 to High(tips) do
  begin
    if (tips[i].Id = adviceId) then
    begin
      result:= i;
      exit;
    end;
  end;
end;

function BH_AddTips(tips: array of BH_Advice; adviceId: string; color: BH_Color; showTime: integer; oneTimeAdvice: boolean):array of BH_Advice;
var
  index: integer;

begin

  result := tips;
  index:= BH_FindTipsIndex(result, adviceId);

  if (index <> -1) then
  begin
    exit;
  end;

  setLength(result, Length(result) + 1);
  result[High(result)].Id := adviceId;
  result[High(result)].ShowTime := showTime;
  result[High(result)].Color := color;
  result[High(result)].OneTimeAdvice := oneTimeAdvice;

end;

procedure BH_AddOneTimePlayerAdvice(playerId: integer; adviceId: string; color: BH_Color; showTime: integer);
var
  playerIndex: integer;
begin
  playerIndex:= BH_FindPlayerIndex(playerId);

  if (playerIndex = -1) then
  begin
    BH_AddPlayer(playerId);
    playerIndex := High(BH_Players);
  end;

  BH_Players[playerIndex].Advices := BH_AddTips(BH_Players[playerIndex].Advices, adviceId, color, showTime, true);
end;

function BH_RemoveTips(advices: array of BH_Advice; adviceId: string):array of BH_Advice;
var
  i: integer;
  index: integer;
  count : integer;
begin

  result:= advices;
  index := BH_FindTipsIndex(result, adviceId);

  if (index = -1) then
  begin
    exit;
  end;

  count:= Length(result);
  for i:= index to count - 2 do
  begin
    result[i]:=result[i+1];
  end;
  SetLength(result, count - 1);

end;


//Iron and gold mines.

function BH_IsMapPoint(x,y: integer): boolean;
begin
  result := (x > 0) and (y > 0) and (x < S.MapWidth) and (y < S.MapHeight);
end;

function BH_GetDistance(first, second: TKMPoint): Single;
begin
  result := U.Power(((first.X - second.X)*(first.X - second.X) + (first.Y - second.Y)*(first.Y - second.Y)), 0.5);
end;

function BH_SafeMapTileIsIron(x,y: integer): boolean;
begin

  result := false;
  if (BH_IsMapPoint(x,y)) then
  begin
    result := S.MapTileIsIron(x, y);
  end;
end;

function BH_SafeMapTileIsGold(x,y: integer): boolean;
begin

  result := false;
  if (BH_IsMapPoint(x,y)) then
  begin
    result := S.MapTileIsGold(x, y);
  end;
end;

function BH_IsIronTile(x,y: integer): boolean;
begin
  result := BH_SafeMapTileIsIron(x, y-1) or BH_SafeMapTileIsIron(x-1, y-1) or BH_SafeMapTileIsIron(x+1, y-1) or BH_SafeMapTileIsIron(x-2, y-1) or BH_SafeMapTileIsIron(x+2, y-1);
end;

function BH_IsGoldTile(x,y: integer): boolean;
begin
  result := BH_SafeMapTileIsGold(x, y-1) or BH_SafeMapTileIsGold(x-1, y-1) or BH_SafeMapTileIsGold(x+1, y-1) or BH_SafeMapTileIsGold(x-2, y-1);
end;

function BH_SafeHouseAt(x, y: integer): integer;
begin
  result := -1;

  if (BH_IsMapPoint(x,y)) then
  begin
    result := S.HouseAt(x,y);
  end;
end;

function BH_CanBuildIronMine(x, y: integer): boolean;
begin

  result := (BH_SafeHouseAt(x-2,y-1) = -1) and (BH_SafeHouseAt(x-2,y  ) = -1) and (BH_SafeHouseAt(x-2,y+1) = -1) and
            (BH_SafeHouseAt(x-1,y+1) = -1) and (BH_SafeHouseAt(x  ,y+1) = -1) and (BH_SafeHouseAt(x+1,y+1) = -1) and
            (BH_SafeHouseAt(x+2,y+1) = -1) and (BH_SafeHouseAt(x+2,y  ) = -1) and (BH_SafeHouseAt(x+2,y-1) = -1);
end;

function BH_CanBuildGoldMine(x, y: integer): boolean;
begin

  result := (BH_SafeHouseAt(x-2,y-1) = -1) and (BH_SafeHouseAt(x-2,y  ) = -1) and (BH_SafeHouseAt(x-2,y+1) = -1) and
            (BH_SafeHouseAt(x-1,y+1) = -1) and (BH_SafeHouseAt(x  ,y+1) = -1) and
            (BH_SafeHouseAt(x+1,y+1) = -1) and (BH_SafeHouseAt(x+1,y  ) = -1) and (BH_SafeHouseAt(x+1,y-1) = -1);
end;

function BH_ExistsPoint(points: array of TKMPoint; x,y: integer): boolean;
var
  i: integer;

begin

  result := false;

  for i:=0 to High(points) do
  begin

    if ((points[i].X = x) and (points[i].Y = y)) then
    begin

      result := true;
      exit;
    end;
  end;
end;

function BH_ReverseExistPoint(points: array of TKMPoint; x,y: integer): boolean;
var
  i: integer;

begin

  result := false;

  for i:=0 to High(points) do
  begin

    if ((points[High(points)-i].X = x) and (points[High(points)-i].Y = y)) then
    begin

      result := true;
      exit;
    end;
  end;
end;

function BH_RemovePoint(points: array of TKMPoint; x,y: integer): array of TKMPoint;
var
  i: integer;

begin

  result := points;

  for i:=0 to High(result) do
  begin
    if ((result[i].X = x) and (result[i].Y = y)) then
    begin

      result[i].X := result[High(result)].X;
      result[i].Y := result[High(result)].Y;

      SetLength(result, Length(result) - 1);
      exit;
    end;
  end;
end;

function BH_AddPoint(points: array of TKMPoint; x,y: integer): array of TKMPoint;
begin
  result := points;
  SetLength(result, Length(result) + 1);
  result[High(result)].X := x;
  result[High(result)].Y := y;
end;

function BH_AddUniquePoint(points: array of TKMPoint; x,y: integer): array of TKMPoint;
begin

  if (not BH_ExistsPoint(points, x, y)) then
  begin
    result := BH_AddPoint(points, x, y);
  end else
  begin
    result := points;
  end;

end;

function BH_AreConflictingPoints(conflicts: array of array of TKMPoint; x1, y1, x2, y2: integer): boolean;
var
  i: integer;
  j: integer;
  firstExist: boolean;
  secondExist: boolean;

begin

  result := false;
  for i := 0 to High(conflicts) do
  begin

    firstExist := false;
    secondExist := false;

    for j := 0 to High(conflicts[i]) do
    begin

      if ((conflicts[i][j].X = x1) and (conflicts[i][j].Y = y1)) then
      begin
        firstExist:= true;
      end;
      if ((conflicts[i][j].X = x2) and (conflicts[i][j].Y = y2)) then
      begin
        secondExist:= true;
      end;

    end;

    if (firstExist and secondExist) then
    begin
      result := true;
      exit;
    end;
  end;
end;

function BH_ExistsConflictingPoint(conflicts: array of array of TKMPoint; points: array of TKMPoint; x, y: integer): boolean;
var
  i: integer;

begin

  result := false;
  for i:= 0 to High(points) do
  begin

    if(BH_AreConflictingPoints(conflicts, points[i].X, points[i].Y, x, y)) then
    begin

      result := true;
      exit;
    end;
  end;

end;

function BH_FillConflictingPoints(conflicts: array of array of TKMPoint; points: array of TKMPoint; x, y: integer): array of TKMPoint;
var
  i: integer;
  j: integer;
  index: integer;

begin

  result := points;

  for i := 0 to High(conflicts) do
  begin

    if (not BH_ExistsPoint(conflicts[i], x, y)) then
    begin
      continue;
    end;

    index:= Length(result);
    SetLength(result, Length(result) + Length(conflicts[i]));

    for j := 0 to High(conflicts[i]) do
    begin

      result[index].X := conflicts[i][j].X;
      result[index].Y := conflicts[i][j].Y;
      Inc(index);

    end;
  end;
end;

function BH_GetPlayerPossibleIronMines(player: BH_Player): integer;
var
  i: integer;
  x: integer;
  y: integer;
  houseId: integer;
  conflictPoints: array of TKMPoint;
  usedPoints: array of TKMPoint;
begin

  for i:=0 to High(player.CloseIronMinesLocations) do
  begin

    x := player.CloseIronMinesLocations[i].X;
    y := player.CloseIronMinesLocations[i].Y;

    houseId := S.HouseAt(x,y);

    if ((houseId > 0) and (not S.HouseIsComplete(houseId)) and (S.HouseOwner(houseId) = player.Id)) then
    begin

      if (BH_ExistsPoint(conflictPoints, x, y)) then
      begin
        continue;
      end;

      conflictPoints := BH_FillConflictingPoints(BH_IronMinesConflicts, conflictPoints, x,y);
      usedPoints := BH_AddPoint(usedPoints, x,y);

    end else
    if ((houseId = -1) and BH_CanBuildIronMine(x,y)) then
    begin

      if (BH_ExistsPoint(conflictPoints, x, y)) then
      begin
        continue;
      end;

      conflictPoints := BH_FillConflictingPoints(BH_IronMinesConflicts, conflictPoints, x,y);
      usedPoints := BH_AddPoint(usedPoints, x,y);


    end;
  end;

  result := Length(usedPoints);
end;

function BH_GetPlayerPossibleGoldMines(player: BH_Player): integer;
var

  i: integer;
  x: integer;
  y: integer;
  houseId: integer;
  conflictPoints: array of TKMPoint;
  usedPoints: array of TKMPoint;
begin

  //TODO. Think how unite this and BH_GetPlayerPossibleIronMines.

  for i:=0 to High(player.CloseGoldMinesLocations) do
  begin

    x := player.CloseGoldMinesLocations[i].X;
    y := player.CloseGoldMinesLocations[i].Y;

    houseId := S.HouseAt(x,y);

    if ((houseId > 0) and (not S.HouseIsComplete(houseId)) and (S.HouseOwner(houseId) = player.Id)) then
    begin

      if (BH_ExistsPoint(conflictPoints, x, y)) then
      begin
        continue;
      end;

      conflictPoints := BH_FillConflictingPoints(BH_GoldMinesConflicts, conflictPoints, x,y);
      usedPoints := BH_AddPoint(usedPoints, x,y);

    end else
    if ((houseId = -1) and BH_CanBuildGoldMine(x,y)) then
    begin

      if (BH_ExistsPoint(conflictPoints, x, y)) then
      begin
        continue;
      end;

      conflictPoints := BH_FillConflictingPoints(BH_GoldMinesConflicts, conflictPoints, x,y);
      usedPoints := BH_AddPoint(usedPoints, x,y);

    end;
  end;

  result := Length(usedPoints);
end;

procedure BH_TryToAddIronConflicts(x, y, tilesInRow: integer);
var
  i: integer;
  toTile: integer;
  index: integer;
  xLocations: array of integer;

begin

  if (tilesInRow < 4) then
  begin
    exit;
  end;

  repeat

    xLocations := [];
    toTile := U.IfThenI((tilesInRow - 3) > 3, x - tilesInRow + 1 + 3, x - 2);

    for i:= x - tilesInRow + 1 to toTile do
    begin
      SetLength(xLocations, Length(xLocations) + 1);
      xLocations[High(xLocations)] := i;
    end;

    SetLength(BH_IronMinesConflicts, Length(BH_IronMinesConflicts) + 1);
    index := High(BH_IronMinesConflicts);
    SetLength(BH_IronMinesConflicts[index], Length(xLocations));

    for i:= 0 to High(xLocations) do
    begin

      BH_IronMinesConflicts[index][i].X := xLocations[i];
      BH_IronMinesConflicts[index][i].Y := y;
    end;

    Dec(tilesInRow);
  until (tilesInRow < 6);
end;

procedure BH_TryToAddGoldConflicts(x, y, tilesInRow: integer);
var
  i: integer;
  toTile: integer;
  index: integer;
  xLocations: array of integer;

begin

  if (tilesInRow < 3) then
  begin
    exit;
  end;

  repeat

    xLocations := [];
    toTile := U.IfThenI((tilesInRow - 2) > 2, x - tilesInRow + 1 + 2, x - 1);

    for i:= x - tilesInRow + 1 to toTile do
    begin
      SetLength(xLocations, Length(xLocations) + 1);
      xLocations[High(xLocations)] := i;
    end;

    SetLength(BH_GoldMinesConflicts, Length(BH_GoldMinesConflicts) + 1);
    index := High(BH_GoldMinesConflicts);
    SetLength(BH_GoldMinesConflicts[index], Length(xLocations));

    for i:= 0 to High(xLocations) do
    begin

      BH_GoldMinesConflicts[index][i].X := xLocations[i];
      BH_GoldMinesConflicts[index][i].Y := y;
    end;

    Dec(tilesInRow);
  until (tilesInRow < 4);
end;

procedure BH_UpdatePlayerMinesInfo(playerId: integer; location :TKMPoint);
var
  i: integer;
  index : integer;

begin

  index := BH_FindPlayerIndex(playerId);

  if (index = -1) then
  begin
    exit;
  end;

  for i:= 0 to High(BH_IronMinesLocations) do
  begin

    if (BH_GetDistance(location, BH_IronMinesLocations[i]) < BH_MinesDistance) then
    begin

      BH_Players[index].CloseIronMinesLocations := BH_AddUniquePoint(BH_Players[index].CloseIronMinesLocations, BH_IronMinesLocations[i].X, BH_IronMinesLocations[i].Y);

    end;
  end;

  for i:= 0 to High(BH_GoldMinesLocations) do
  begin

    if (BH_GetDistance(location, BH_GoldMinesLocations[i]) < BH_MinesDistance) then
    begin

      BH_Players[index].CloseGoldMinesLocations := BH_AddUniquePoint(BH_Players[index].CloseGoldMinesLocations, BH_GoldMinesLocations[i].X, BH_GoldMinesLocations[i].Y);

    end;
  end;

end;

//Roads.

procedure BH_InitMapTile(x, y: integer);
begin

  if (S.IsRoadAt(-1,x,y)) then
  begin

    BH_MapTilesInfo[x][y].RoadTileType := RTT_Road;
    BH_MapTilesInfo[x][y].RoadConnectionType := RCT_Strong;
  end;

end;

function BH_SaveGetRoadConnectionType(x,y: integer): BH_RoadConnectionType;
begin

  result := RCT_Null;
  if (BH_IsMapPoint(x,y)) then
  begin
    result := BH_MapTilesInfo[x][y].RoadConnectionType;
  end;
end;

function BH_GetBestConnection(first,second: BH_RoadConnectionType): BH_RoadConnectionType;
begin

  if (first = RCT_Strong) then
  begin
    result := first;
    exit;
  end;

  if ((first = RCT_Weak) and (second = RCT_Null)) then
  begin
    result := first;
    exit;
  end;

  result := second;
end;

function BH_GetBestNeighborConnection(x,y: integer): BH_RoadConnectionType;
begin

  result := BH_SaveGetRoadConnectionType(x-1,y);

  if (result = RCT_Strong) then
    exit;

  result := BH_GetBestConnection(result, BH_SaveGetRoadConnectionType(x+1,y));

  if (result = RCT_Strong) then
    exit;

  result := BH_GetBestConnection(result, BH_SaveGetRoadConnectionType(x,y-1));

  if (result = RCT_Strong) then
    exit;

  result := BH_GetBestConnection(result, BH_SaveGetRoadConnectionType(x,y+1));

end;

procedure BH_ConnectRoads(x,y: integer; connectionType: BH_RoadConnectionType);
begin

  BH_MapTilesInfo[x][y].LastUsedPointHash := 0;

  if ((not BH_IsMapPoint(x,y)) or (BH_MapTilesInfo[x][y].RoadTileType = RTT_Null)) then
  begin
    exit;
  end;

  if (BH_MapTilesInfo[x][y].RoadConnectionType = RCT_Strong) then
  begin
    exit;
  end;

  if (BH_MapTilesInfo[x][y].RoadConnectionType = connectionType) then
  begin
    exit;
  end;

  if ((connectionType = RCT_Strong) and (BH_MapTilesInfo[x][y].RoadTileType <> RTT_Road)) then
  begin
    exit;
  end;

  BH_MapTilesInfo[x][y].RoadConnectionType := connectionType;

  BH_ConnectRoads(x  , y-1, connectionType);
  BH_ConnectRoads(x  , y+1, connectionType);
  BH_ConnectRoads(x-1, y  , connectionType);
  BH_ConnectRoads(x+1, y  , connectionType);

  //A.Log('Was Connected : ' + IntToStr(x) + ';' + IntToStr(y) + ' ' + IntToStr(BH_MapTilesInfo[x][y].RoadConnectionType));
end;

function BH_CheckConnection(hash: integer; x,y: integer): boolean;
begin

  result := false;

  if ((not BH_IsMapPoint(x,y)) or (BH_MapTilesInfo[x][y].RoadTileType = RTT_Null)) then
  begin
    exit;
  end;

  if (BH_MapTilesInfo[x][y].RoadConnectionType = RCT_Strong) then
  begin
    result := true;
    exit;
  end;

  if (BH_MapTilesInfo[x][y].LastUsedPointHash = hash) then
  begin
    exit;
  end;

  BH_MapTilesInfo[x][y].LastUsedPointHash := hash;

  //Rare case if you are building normaly. But if you make too many roads this will crush game.
  //if (Length(usedPoints) > 13) then
  //begin
  //  result := false;
  //  exit;
  //end;

  if (BH_CheckConnection(hash, x  , y-1)) then
  begin
    result := true;
    exit;
  end;

  if (BH_CheckConnection(hash, x  , y+1)) then
  begin
    result := true;
    exit;
  end;

  if (BH_CheckConnection(hash, x-1, y  )) then
  begin
    result := true;
    exit;
  end;

  if (BH_CheckConnection(hash, x+1, y  )) then
  begin
    result := true;
    exit;
  end;
end;

procedure BH_FillMapInfo();
var
  x: integer;
  y: integer;
  tileType: integer;
  ironTilesInRow: integer;
  goldTilesInRow: integer;

begin

  SetLength(BH_MapTilesInfo, S.MapWidth + 1);

  for y:=1 to S.MapWidth - 1 do
  begin
    SetLength(BH_MapTilesInfo[y], S.MapHeight + 1);
  end;

  for y:=1 to S.MapHeight - 1 do
  begin

    BH_TryToAddIronConflicts(x,y,ironTilesInRow);
    ironTilesInRow := 0;

    BH_TryToAddGoldConflicts(x,y-1,goldTilesInRow);
    goldTilesInRow := 0;

    for x:=1 to S.MapWidth - 1 do
    begin

      BH_InitMapTile(x,y);

      tileType := S.MapTileType(x,y);

      if ((tileType = 167) or (tileType = 168)) then
      begin

        BH_TryToAddGoldConflicts(x,y,goldTilesInRow);
        goldTilesInRow := 0;

        if ((S.MapTileRotation(x,y) <> 0) or (not BH_IsIronTile(x,y))) then
        begin

          BH_TryToAddIronConflicts(x,y,ironTilesInRow);
          ironTilesInRow := 0;

          continue;
        end;

        Inc(ironTilesInRow);

        if (ironTilesInRow >= 3) then
        begin

          BH_IronMinesLocations := BH_AddPoint(BH_IronMinesLocations, x-1, y);
        end;


      end else
      if ((tileType = 172) or (tileType = 175))  then
      begin

        BH_TryToAddIronConflicts(x,y,ironTilesInRow);
        ironTilesInRow := 0;

        if ((S.MapTileRotation(x,y) <> 0) or (not BH_IsGoldTile(x,y))) then
        begin
          BH_TryToAddGoldConflicts(x,y,goldTilesInRow);
          goldTilesInRow := 0;
          continue;
        end;

        Inc(goldTilesInRow);

        if (goldTilesInRow >= 2) then
        begin

          BH_GoldMinesLocations := BH_AddPoint(BH_GoldMinesLocations, x, y);
        end;
      end else
      begin

        BH_TryToAddIronConflicts(x,y,ironTilesInRow);
        ironTilesInRow := 0;

        BH_TryToAddGoldConflicts(x,y,goldTilesInRow);
        goldTilesInRow := 0;
      end;

    end;
  end;
end;

//BH_BuildingsCountInfo

function BH_GetPlayerBuildingsCountInfo(playerId: integer): BH_BuildingsCountInfo;
begin
  result.School := S.StatHouseTypeCountEx(playerId, htSchool);
  result.Inn:= S.StatHouseTypeCountEx(playerId, htInn);
  result.Quarry:= S.StatHouseTypeCountEx(playerId, htQuarry);
  result.Woodcutters:= S.StatHouseTypeCountEx(playerId, htWoodcutters);
  result.Sawmill:= S.StatHouseTypeCountEx(playerId, htSawmill);
  result.Farm:= S.StatHouseTypeCountEx(playerId, htFarm);
  result.Mill:= S.StatHouseTypeCountEx(playerId, htMill);
  result.Bakery:= S.StatHouseTypeCountEx(playerId, htBakery);
  result.Swine:= S.StatHouseTypeCountEx(playerId, htSwine);
  result.Butchers:= S.StatHouseTypeCountEx(playerId, htButchers);
  result.Vineyard:= S.StatHouseTypeCountEx(playerId, htVineyard);
  result.Goldmine:= S.StatHouseTypeCountEx(playerId, htGoldmine);
  result.Coalmine:= S.StatHouseTypeCountEx(playerId, htCoalmine);
  result.Metallurgists:= S.StatHouseTypeCountEx(playerId, htMetallurgists);
  result.Weaponworkshop:= S.StatHouseTypeCountEx(playerId, htWeaponworkshop);
  result.Tannery:= S.StatHouseTypeCountEx(playerId, htTannery);
  result.Armorworkshop:= S.StatHouseTypeCountEx(playerId, htArmorworkshop);
  result.Stables:= S.StatHouseTypeCountEx(playerId, htStables);
  result.Ironmine:= S.StatHouseTypeCountEx(playerId, htIronmine);
  result.Ironsmithy:= S.StatHouseTypeCountEx(playerId, htIronsmithy);
  result.Weaponsmithy:= S.StatHouseTypeCountEx(playerId, htWeaponsmithy);
  result.Armorsmithy:= S.StatHouseTypeCountEx(playerId, htArmorsmithy);
  result.Barracks:= S.StatHouseTypeCountEx(playerId, htBarracks);
  result.Store:= S.StatHouseTypeCountEx(playerId, htStore);
  result.WatchTower:= S.StatHouseTypeCountEx(playerId, htWatchTower);
  result.Fishermans:= S.StatHouseTypeCountEx(playerId, htFishermans);
  result.Market:= S.StatHouseTypeCountEx(playerId, htMarket);
  result.TownHall:= S.StatHouseTypeCountEx(playerId, htTownHall);
end;

function BH_ChangeBuildingsCountInfo(buildings: BH_BuildingsCountInfo; buildingType: TKMHouseType; count: integer): BH_BuildingsCountInfo;
begin

  result := buildings;

  case buildingType of
    htSchool:
      result.School := result.School + count;
    htInn:
      result.Inn := result.Inn + count;
    htQuarry:
      result.Quarry := result.Quarry + count;
    htWoodcutters:
      result.Woodcutters := result.Woodcutters + count;
    htSawmill:
      result.Sawmill := result.Sawmill + count;
    htFarm:
      result.Farm := result.Farm + count;
    htMill:
      result.Mill := result.Mill + count;
    htBakery:
      result.Bakery := result.Bakery + count;
    htSwine:
      result.Swine := result.Swine + count;
    htButchers:
      result.Butchers := result.Butchers + count;
    htVineyard:
      result.Vineyard := result.Vineyard + count;
    htGoldmine:
      result.Goldmine := result.Goldmine + count;
    htCoalmine:
      result.Coalmine := result.Coalmine + count;
    htMetallurgists:
      result.Metallurgists := result.Metallurgists + count;
    htWeaponworkshop:
      result.Weaponworkshop := result.Weaponworkshop + count;
    htTannery:
      result.Tannery := result.Tannery + count;
    htArmorworkshop:
      result.Armorworkshop := result.Armorworkshop + count;
    htStables:
      result.Stables := result.Stables + count;
    htIronmine:
      result.Ironmine := result.Ironmine + count;
    htIronsmithy:
      result.Ironsmithy := result.Ironsmithy + count;
    htWeaponsmithy:
      result.Weaponsmithy := result.Weaponsmithy + count;
    htArmorsmithy:
      result.Armorsmithy := result.Armorsmithy + count;
    htBarracks:
      result.Barracks := result.Barracks + count;
    htStore:
      result.Store := result.Store + count;
    htWatchTower:
      result.WatchTower := result.WatchTower + count;
    htFishermans:
      result.Fishermans := result.Fishermans + count;
    htMarket:
      result.Market := result.Market + count;
    htTownHall:
      result.TownHall := result.TownHall + count;
  end;
end;

function BH_ExtendBuildingsCountInfo(buildings: BH_BuildingsCountInfo; addingBuildings: array of BH_BuildingInfo) : BH_BuildingsCountInfo;
var
  i: integer;

begin

  result := buildings;

  for i:= 0 to High(addingBuildings) do
  begin
    result := BH_ChangeBuildingsCountInfo(result, addingBuildings[i].BuildingType, addingBuildings[i].Count);
  end;

end;

//BH_CitizensCountInfo

function BH_ChangeCitizensCountInfo(units: BH_CitizensCountInfo; unitType: TKMUnitType; count: integer): BH_CitizensCountInfo;
begin

  result := units;

  case unitType of
    utWoodcutter:
      result.Woodcutter := result.Woodcutter + count;
    utMiner:
      result.Miner := result.Miner + count;
    utAnimalBreeder:
      result.AnimalBreeder := result.AnimalBreeder + count;
    utFarmer:
      result.Farmer := result.Farmer + count;
    utCarpenter:
      result.Carpenter := result.Carpenter + count;
    utBaker:
      result.Baker := result.Baker + count;
    utButcher:
      result.Butcher := result.Butcher + count;
    utFisher:
      result.Fisher := result.Fisher + count;
    utStonemason:
      result.Stonemason := result.Stonemason + count;
    utSmith:
      result.Smith := result.Smith + count;
    utMetallurgist:
      result.Metallurgist := result.Metallurgist + count;
    utRecruit:
      result.Recruit := result.Recruit + count;

  end;
end;

function BH_BuildingsCountInfoToCitizensCountInfo(buildings: BH_BuildingsCountInfo): BH_CitizensCountInfo;
begin

  result.Woodcutter := buildings.Woodcutters;
  result.Miner := buildings.GoldMine + buildings.IronMine + buildings.CoalMine;
  result.AnimalBreeder := buildings.Swine + buildings.Stables;
  result.Farmer := buildings.Farm + buildings.Vineyard;
  result.Carpenter := buildings.Sawmill + buildings.WeaponWorkshop + buildings.ArmorWorkshop;
  result.Baker := buildings.Mill + buildings.Bakery;
  result.Butcher := buildings.Tannery + buildings.Butchers;
  result.Fisher := buildings.Fishermans;
  result.Stonemason := buildings.Quarry;
  result.Smith := buildings.WeaponSmithy + buildings.ArmorSmithy;
  result.Metallurgist := buildings.Metallurgists + buildings.IronSmithy;
  result.Recruit := buildings.WatchTower;

end;

//BH_Player

procedure BH_AddPlayerStrategy(playerId: integer; strategy: BH_BuildingStrategy);
var
  index: integer;

begin

  index := BH_FindPlayerIndex(playerId);
  if (index = -1) then
  begin
    BH_AddPlayer(playerId);
    index := High(BH_Players);
  end;

  BH_Players[index].BuildingStrategy := strategy;
end;

function BH_GetPlayerBuildingTypeIds(playerId: integer; buildingType: TKMHouseType): array of integer;
var
  playerIndex: integer;
  buildingIndex: integer;

begin

  result := [];
  playerIndex := BH_FindPlayerIndex(playerId);

  if (playerIndex = -1) then
  begin
    exit;
  end;

  buildingIndex := BH_FindBuildingInCollectionIndex(BH_Players[playerIndex].Buildings, buildingType);

  if (buildingIndex = -1) then
  begin
    exit;
  end;

  result := BH_Players[playerIndex].Buildings[buildingIndex].Ids;
end;

function BH_GetPlayerBuildingPlansLocations(playerId: integer; buildingType: TKMHouseType): array of TKMPoint;
var
  playerIndex: integer;
  buildingIndex: integer;

begin

  result := [];
  playerIndex := BH_FindPlayerIndex(playerId);

  if (playerIndex = -1) then
  begin
    exit;
  end;

  buildingIndex := BH_FindBuildingPlanInCollectionIndex(BH_Players[playerIndex].BuildingPlans, buildingType);

  if (buildingIndex = -1) then
  begin
    exit;
  end;

  result := BH_Players[playerIndex].BuildingPlans[buildingIndex].Locations;
end;

procedure BH_AddPlayerBuilding(playerId: integer; houseId: integer);
var
  playerIndex: integer;
  buildingIndex: integer;
  buildingType: TKMHouseType;
  count: integer;
begin

  playerIndex:= BH_FindPlayerIndex(playerId);

  if (playerIndex = -1) then
  begin
    exit;
  end;

  buildingType := S.HouseTypeEx(houseId);
  buildingIndex := BH_FindBuildingInCollectionIndex(BH_Players[playerIndex].Buildings, buildingType);

  if (buildingIndex = -1) then
  begin
    BH_Players[playerIndex].Buildings := BH_AddBuildingTypeToCollection(BH_Players[playerIndex].Buildings, buildingType);
    buildingIndex := High(BH_Players[playerIndex].Buildings);
  end;

  count := Length(BH_Players[playerIndex].Buildings[buildingIndex].Ids);
  setLength(BH_Players[playerIndex].Buildings[buildingIndex].Ids, count + 1);
  BH_Players[playerIndex].Buildings[buildingIndex].Ids[count] := houseId;
end;

procedure BH_RemovePlayerBuilding(playerId: integer; houseId: integer);
var
  playerIndex: integer;
  buildingIndex: integer;
  elementIndex: integer;
  buildingType: TKMHouseType;
begin

  playerIndex:= BH_FindPlayerIndex(playerId);

  if (playerIndex = -1) then
  begin
    exit;
  end;

  buildingType := S.HouseTypeEx(houseId);
  buildingIndex := BH_FindBuildingInCollectionIndex(BH_Players[playerIndex].Buildings, buildingType);

  if (buildingIndex = -1) then
  begin
    exit;
  end;

  elementIndex := BH_FindElementIndex(BH_Players[playerIndex].Buildings[buildingIndex].Ids, houseId);

  if (elementIndex <> -1) then
  begin
    BH_Players[playerIndex].Buildings[buildingIndex].Ids := U.ArrayRemoveIndexI(elementIndex, BH_Players[playerIndex].Buildings[buildingIndex].Ids);
  end;

end;

procedure BH_AddPlayerBuildingPlan(playerId: integer; buildingType: TKMHouseType; x,y: integer);
var
  playerIndex: integer;
  buildingIndex: integer;
  count: integer;
begin

  playerIndex:= BH_FindPlayerIndex(playerId);

  if (playerIndex = -1) then
  begin
    exit;
  end;

  buildingIndex := BH_FindBuildingPlanInCollectionIndex(BH_Players[playerIndex].BuildingPlans, buildingType);

  if (buildingIndex = -1) then
  begin
    BH_Players[playerIndex].BuildingPlans := BH_AddBuildingPlanTypeToCollection(BH_Players[playerIndex].BuildingPlans, buildingType);
    buildingIndex := High(BH_Players[playerIndex].BuildingPlans);
  end;

  count := Length(BH_Players[playerIndex].BuildingPlans[buildingIndex].Locations);
  setLength(BH_Players[playerIndex].BuildingPlans[buildingIndex].Locations, count + 1);
  BH_Players[playerIndex].BuildingPlans[buildingIndex].Locations[count].X := x;
  BH_Players[playerIndex].BuildingPlans[buildingIndex].Locations[count].Y := y;
end;

procedure BH_RemovePlayerBuildingPlan(playerId: integer; buildingType: TKMHouseType; x,y: integer);
var
  playerIndex: integer;
  buildingIndex: integer;
begin

  playerIndex:= BH_FindPlayerIndex(playerId);

  if (playerIndex = -1) then
  begin
    exit;
  end;

  buildingIndex := BH_FindBuildingPlanInCollectionIndex(BH_Players[playerIndex].BuildingPlans, buildingType);

  if (buildingIndex = -1) then
  begin
    exit;
  end;

  if (BH_ExistsPoint(BH_Players[playerIndex].BuildingPlans[buildingIndex].Locations, x,y)) then
  begin
    BH_Players[playerIndex].BuildingPlans[buildingIndex].Locations := BH_RemovePoint(BH_Players[playerIndex].BuildingPlans[buildingIndex].Locations, x, y);
  end;
end;

procedure BH_AddPlayerAdvice(playerId: integer; adviceId: string; color: BH_Color; showTime: integer);
var
  playerIndex: integer;
begin
  playerIndex:= BH_FindPlayerIndex(playerId);

  if (playerIndex = -1) then
  begin
    exit;
  end;

  BH_Players[playerIndex].Advices := BH_AddTips(BH_Players[playerIndex].Advices, adviceId, color, showTime, false);
end;

function BH_GetMaxPlayerPlannedBuildings(player: BH_Player; planning: boolean): integer;
var
  buildersCount: integer;

begin

  buildersCount := States.StatUnitTypeCountEx(player.Id, utBuilder);

  result := 2 + (buildersCount div 4);
  //if (buildersCount div 6 > 0) then
  //begin
  //  result := result + 1;
  //end;

  if (planning) then
  begin
    result := result + 1;
    if (result > 6) then
    begin
      result := 6;
    end;
  end;
end;

function BH_GetMaxPlayerPlannedBuildingsById(playerId: integer; planning : boolean): integer;
var
  index: integer;

begin

  index:= BH_FindPlayerIndex(playerId);

  if (index = -1)then
  begin
    exit;
  end;

  result := BH_GetMaxPlayerPlannedBuildings(BH_Players[index], planning);
end;

function BH_IsWareLocked(playerId: integer; wareType: TKMWareType): boolean;
var
  i: integer;
  ids: array of integer;

begin

  result := true;

  ids := BH_GetPlayerBuildingTypeIds(playerId, htSwine);

  for i:= 0 to High(ids) do
  begin
    if (S.HouseDeliveryBlocked(ids[i])) then
    begin
      continue;
    end;

    if (not S.HouseWareBlockedEx(ids[i], wareType)) then
    begin
      result := false;
      exit;
    end;
  end;
end;

function BH_GetPlayerPigsCount(playerId: integer): integer;
var
  i: integer;
  ids: array of integer;

begin

  result := 0;
  ids := BH_GetPlayerBuildingTypeIds(playerId, htSwine);

  for i:= 0 to High(ids) do
  begin
    result := result + S.HouseWareAmount(ids[i], wtPig);
  end;

  ids := BH_GetPlayerBuildingTypeIds(playerId, htStore);

  for i:= 0 to High(ids) do
  begin
    result := result + S.HouseWareAmount(ids[i], wtPig);
  end;
end;

function BH_GetPlayerSkinsCount(playerId: integer): integer;
var
  i: integer;
  ids: array of integer;

begin

  result := 0;
  ids := BH_GetPlayerBuildingTypeIds(playerId, htTannery);

  for i:= 0 to High(ids) do
  begin
    result := result + S.HouseWareAmount(ids[i], wtSkin);
  end;

  ids := BH_GetPlayerBuildingTypeIds(playerId, htStore);

  for i:= 0 to High(ids) do
  begin
    result := result + S.HouseWareAmount(ids[i], wtSkin);
  end;
end;

function BH_GetPlayerStartingFoodAmount(playerId: integer): BH_FoodAmountEnum;
var
  index: integer;

begin

  result := FA_VERY_LOW;
  index:= BH_FindPlayerIndex(playerId);

  if (index = -1)then
  begin
    exit;
  end;

  result := BH_Players[index].StartingFoodAmount;
end;

function BH_GetPlayerConnectedHousePlansCount(playerId: integer; buildingType: TKMHouseType): integer;
var
  i: integer;
  locations: array of TKMPoint;

begin

  result := 0;
  locations := BH_GetPlayerBuildingPlansLocations(playerId, buildingType);

  for i := 0 to High(Locations) do
  begin

    if (BH_MapTilesInfo[locations[i].X][locations[i].Y + 1].RoadConnectionType <> RCT_Null) then
    begin
      Inc(result);
    end;
  end;

end;

function BH_IsWareLockedAtPlayerStorehouses(playerId: integer; wareType: TKMWareType): boolean;
var
  index: integer;
  ids: array of integer;
  i: integer;

begin

  result := true;
  index := BH_FindPlayerIndex(playerId);

  if (index = -1) then
  begin
    exit;
  end;

  ids := BH_GetPlayerBuildingTypeIds(playerId, htStore);

  for i:= 0 to High(ids) do
  begin

    if (not S.HouseWareBlockedEx(ids[i], wareType))then
    begin

      result := false;
      exit;
    end;
  end;

end;

function BH_ArePlayerHousesLocked(playerId: integer; houseType: TKMHouseType): boolean;
var
  index: integer;
  ids: array of integer;
  i: integer;

begin

  result := true;
  index := BH_FindPlayerIndex(playerId);

  if (index = -1) then
  begin
    exit;
  end;

  ids := BH_GetPlayerBuildingTypeIds(playerId, houseType);

  for i:= 0 to High(ids) do
  begin

    if (not S.HouseDeliveryBlocked(ids[i]))then
    begin

      result := false;
      exit;
    end;
  end;

end;

///TODO remove when HouseSchoolQueueEx will be implemented.
function BH_GetUnitType(unitType: integer) : TKMUnitType;
begin
  case unitType of
    0: result := utSerf;
    1: result := utWoodcutter;
    2: result := utMiner;
    3: result := utAnimalBreeder;
    4: result := utFarmer;
    5: result := utCarpenter;
    6: result := utBaker;
    7: result := utButcher;
    8: result := utFisher;
    9: result := utBuilder;

    10: result := utStonemason;
    11: result := utSmith;
    12: result := utMetallurgist;
    13: result := utRecruit;
    14: result := utMilitia;
    15: result := utAxefighter;
    16: result := utSwordfighter;
    17: result := utBowman;
    18: result := utCrossbowman;
    19: result := utLanceCarrier;

    20: result := utPikeman;
    21: result := utScout;
    22: result := utKnight;
    23: result := utBarbarian;
    24: result := utRebel;
    25: result := utRogue;
    26: result := utWarrior;
    27: result := utVagabond;

    30: result := utWolf;
    31: result := utFish;
    32: result := utWatersnake;
    33: result := utSeastar;
    34: result := utCrab;
    35: result := utWaterflower;
    36: result := utWaterleaf;
    37: result := utDuck;
    else
      result := utNone;
  end;
end;

procedure BH_RefreshTips(playerIndex: integer);
var
  i: integer;

begin

  for i:= 0 to Length(BH_Players[playerIndex].Advices) - 1 do
  begin
    Dec(BH_Players[playerIndex].Advices[i].ShowTime);
    if ((BH_Players[playerIndex].Advices[i].ShowTime <= 0) and (not BH_Players[playerIndex].Advices[i].OneTimeAdvice)) then
    begin
      BH_Players[playerIndex].Advices := BH_RemoveTips(BH_Players[playerIndex].Advices, BH_Players[playerIndex].Advices[i].Id);
      Dec(i);
    end;
  end;
end;

//String functions.
function BH_GetBuildingStrategyString(strategy: BH_BuildingStrategy): string;
begin
  case strategy of
    BS_Default35, BS_Default_60:
      result := 'Default';
    BS_IronStoring_60:
      result := 'BS_IronStoring_60';
  end;
end;

function BH_GetBuildingsInfoString(buildings: array of BH_BuildingInfo):string;
var
  i: integer;
begin

  for i:= 0 to High(buildings) do
  begin
    result := result + S.HouseTypeNameEx(buildings[i].BuildingType) + '  ' + IntToStr(buildings[i].Count) + '|';
  end;

end;

function BH_GetBuildingsCollectionString(buildings: array of BH_BuildingCollection):string;
var
  i: integer;
begin

  for i:= 0 to High(buildings) do
  begin
    result := result + S.HouseTypeNameEx(buildings[i].BuildingType) + '  ' + IntToStr(Length(buildings[i].ids)) + '|';
  end;
end;

function BH_GetPointsCollectionString(points: array of TKMPoint): string;
var
  i: integer;
begin

  for i:= 0 to High(points) do
  begin
    result := result + '(' + IntToStr(points[i].X) + ';' + IntToStr(points[i].Y) + ') ';
    if ((i<>0) and (i mod 20 = 0)) then
    begin
      result := result + '|';
    end;
  end;

end;

function BH_GetDebugOverlayString(playerIndex: integer): string;
var i: integer;

begin


  //result := result + 'Buildings collection: |' + BH_GetBuildingsCollectionString(BH_Players[playerIndex].Buildings);

  for i:= 0 to High(BH_Players[playerIndex].BuildingPlans) do
  begin
    result := result + 'Player house plans: ' + S.HouseTypeNameEx(BH_Players[playerIndex].BuildingPlans[i].BuildingType) + ' ' + BH_GetPointsCollectionString(BH_Players[playerIndex].BuildingPlans[i].Locations) + '|';
  end;



  //Global mines info.
  {
  result := result + 'Iron mines: |' + BH_GetPointsCollectionString(BH_IronMinesLocations) + '|';
  result := result + 'Gold mines: |' + BH_GetPointsCollectionString(BH_GoldMinesLocations) + '|';

  result := result + 'Iron conflicts: |';
  for i:= 0 to High(BH_IronMinesConflicts) do
  begin
    result := result + BH_GetPointsCollectionString(BH_IronMinesConflicts[i])+ '|';
  end;

  result := result + 'Gold conflicts: |';

  for i:= 0 to High(BH_GoldMinesConflicts) do
  begin
    result := result + BH_GetPointsCollectionString(BH_GoldMinesConflicts[i])+ '|';
  end;
  }

  //Player mines info.
  {
  result := result + 'Player iron mines: |' + BH_GetPointsCollectionString(BH_Players[playerIndex].CloseIronMinesLocations) + '|';
  result := result + IntToStr(BH_Players[playerIndex].PossibleIronMinesCount) + '|';
  result := result + 'Player gold mines: |' + BH_GetPointsCollectionString(BH_Players[playerIndex].CloseGoldMinesLocations) + '|';
  result := result + IntToStr(BH_Players[playerIndex].PossibleGoldMinesCount) + '|';
  }


end;

function BH_GetColor(color: BH_Color): string;
begin
  case color of
    Color_White:
      result := '[$FFFFFF]';
    Color_Green:
      result := '[$00FF00]';
    Color_Yellow:
      result := '[$00FFFF]';
    Color_Red:
      result := '[$0000FF]';
    Color_Blue:
      result := '[$FF0000]';
  end;
end;

//----------------------------------------------------------------------------------------------------------------------------------------------------
//EVENTS.
//----------------------------------------------------------------------------------------------------------------------------------------------------

procedure BH_OnRoadBuiltCore(playerId: integer; x, y: integer);
var
  connectionType: BH_RoadConnectionType;

begin

  BH_MapTilesInfo[x][y].RoadTileType := RTT_Road;

  connectionType := BH_GetBestNeighborConnection(x,y);

  if (connectionType <> RCT_Null) then
  begin
    BH_ConnectRoads(x,y, connectionType);
  end;

end;

procedure BH_OnPlanRoadPlacedCore(playerId: integer; x, y: integer);
var
  connectionType: BH_RoadConnectionType;

begin

  BH_MapTilesInfo[x][y].RoadTileType := RTT_RoadPlan;

  connectionType := BH_GetBestNeighborConnection(x,y);

  //A.Log('Trying to connect : ' + IntToStr(x) + ';' + IntToStr(y));

  if (connectionType <> RCT_Null) then
  begin

    //A.Log('Connecting : ' + IntToStr(x) + ';' + IntToStr(y) + ' ' + IntToStr(connectionType));
    BH_ConnectRoads(x,y, RCT_Weak);
  end;

end;

procedure BH_OnPlanRoadRemovedCore(playerId: integer; x, y: integer);
begin

  BH_MapTilesInfo[x][y].RoadTileType := RTT_Null;
  BH_MapTilesInfo[x][y].RoadConnectionType := RCT_Null;

  if (not BH_CheckConnection(x*y, x  ,y-1)) then
  begin
    BH_ConnectRoads(x,y-1, RCT_Null);
  end;

  if (not BH_CheckConnection(x*y, x  ,y+1)) then
  begin
    BH_ConnectRoads(x,y+1, RCT_Null);
  end;

  if (not BH_CheckConnection(x*y, x-1,y  )) then
  begin
    BH_ConnectRoads(x-1,y, RCT_Null);
  end;

  if (not BH_CheckConnection(x*y, x+1,y  )) then
  begin
    BH_ConnectRoads(x+1,y, RCT_Null);
  end;
end;

procedure BH_OnHousePlanPlacedExCore(playerId: integer; x, y: integer; houseType: TKMHouseType);
begin
  BH_AddPlayerBuildingPlan(playerId, houseType, x,y);
end;

procedure BH_OnHousePlanRemovedExCore(playerId: integer; x, y: integer; houseType: TKMHouseType);
begin
  BH_RemovePlayerBuildingPlan(playerId, houseType, x,y);
end;

procedure BH_OnHouseBuiltCore(aHouse: integer);
var
  index: integer;
  ownerId: integer;
  houseType: TKMHouseType;
  location: TKMPoint;

begin
  ownerId := S.HouseOwner(aHouse);
  BH_AddPlayerBuilding(ownerId, aHouse);

  BH_UpdatePlayerMinesInfo(ownerId, S.HousePosition(aHouse));

  houseType := S.HouseTypeEx(aHouse);
  location := S.HousePosition(aHouse);

  BH_RemovePlayerBuildingPlan(ownerId, houseType, location.X,location.Y);

  if (houseType = htGoldMine) then
  begin

    BH_GoldMinesLocations := BH_RemovePoint(BH_GoldMinesLocations, location.X, location.Y);
  end else
  if (houseType = htIronMine) then
  begin

    BH_IronMinesLocations := BH_RemovePoint(BH_IronMinesLocations, location.X, location.Y);
  end else
  if (houseType = htFarm) then
  begin

    index := BH_FindPlayerIndex(ownerId);
    if ((index <> -1) and (BH_Players[index].FirstFarmTime = 0)) then
    begin
      BH_Players[index].FirstFarmTime := S.GameTime;
    end;

  end;
end;

procedure BH_OnHouseDestroyedCore(aHouse: integer; aDestroyerIndex: integer);
var
  ownerId: integer;
  houseType: TKMHouseType;
  location: TKMPoint;

begin
  ownerId := S.HouseOwner(aHouse);
  BH_RemovePlayerBuilding(ownerId, aHouse);

  houseType := S.HouseTypeEx(aHouse);
  location := S.HousePosition(aHouse);

  BH_RemovePlayerBuildingPlan(ownerId, houseType, location.X,location.Y);

  if (houseType = htGoldMine) then
  begin

    if (S.HouseCanReachResources(aHouse)) then
    begin
      BH_GoldMinesLocations := BH_AddPoint(BH_GoldMinesLocations, location.X, location.Y);
    end;

    //TODO. else remove from all players and remove from conflicts.

  end else
  if (houseType = htIronMine) then
  begin

    if (S.HouseCanReachResources(aHouse)) then
    begin
      BH_IronMinesLocations := BH_AddPoint(BH_IronMinesLocations, location.X, location.Y);
    end;

    //TODO. else remove from all players and remove from conflicts.

  end;

end;

procedure BH_OnMissionStartCore;
var
  i: integer;
  index: integer;
  playerId: integer;
  ids: array of integer;
  foodAmount: single;

begin

  if (BH_GlobalBuildingStrategy = BS_Null) then
  begin
    BH_GlobalBuildingStrategy := BS_Default_60;
  end;

  A.LogLinesMaxCnt(5000);
  BH_FillMapInfo();

  for playerId:= 0 to S.LocationCount - 1 do
  begin

    if (not S.PlayerEnabled(playerId) or S.PlayerIsAI(playerId)) then
    begin
      continue;
    end;

    //if (not S.PlayerEnabled(playerId)) then
    //begin
    //  continue;
    //end;

    index := BH_FindPlayerIndex(playerId);

    if (index = -1) then
    begin
      BH_AddPlayer(playerId);
      index := High(BH_Players);
    end;

    ids := S.PlayerGetAllHouses(playerId);

    foodAmount := 0;

    for i:= 0 to High(ids) do
    begin
      BH_AddPlayerBuilding(playerId, ids[i]);

      if (S.HouseTypeEx(ids[i]) = htStore) then
      begin

        foodAmount := S.HouseWareAmount(ids[i], wtSausage) * BH_Sausage + foodAmount;
        foodAmount := S.HouseWareAmount(ids[i], wtFish) * BH_Fish + foodAmount;
        foodAmount := S.HouseWareAmount(ids[i], wtBread) * BH_Bread + foodAmount;
        foodAmount := S.HouseWareAmount(ids[i], wtWine) * BH_Wine + foodAmount;
      end;

      BH_UpdatePlayerMinesInfo(playerId, S.HousePosition(ids[i]));
    end;

    if (foodAmount <= 27) then
    begin
      BH_Players[index].StartingFoodAmount := FA_VERY_LOW;
    end else
    if ((foodAmount >= 27) and (foodAmount < 36)) then
    begin
      BH_Players[index].StartingFoodAmount := FA_LOW;
    end else
    if ((foodAmount >= 36) and (foodAmount < 45)) then
    begin
      BH_Players[index].StartingFoodAmount := FA_OK;
    end else
    if ((foodAmount >= 45) and (foodAmount < 54)) then
    begin
      BH_Players[index].StartingFoodAmount := FA_HIGH;
    end else
    if (foodAmount >= 54) then
    begin
      BH_Players[index].StartingFoodAmount := FA_VERY_HIGH;
    end;

    if (not S.PlayerHouseTypeCanBuild(playerId, htInn)) then
    begin
      BH_Players[index].IsSlowBuildOrder := true;
    end;

    //TODO move from core.
    BH_Players[index].Advices := BH_AddTips(BH_Players[index].Advices, '<$0>', Color_White, 60, true);
  end;

end;

procedure BH_OnTickCore;
var

  i: integer;
begin

  if (BH_NeedToUpdate and ((S.GameTime - 1) mod 2 = 0)) then
  begin
    BH_Players[BH_MinesUpdateIndex].PossibleIronMinesCount := BH_GetPlayerPossibleIronMines(BH_Players[BH_MinesUpdateIndex]);
    BH_Players[BH_MinesUpdateIndex].PossibleGoldMinesCount := BH_GetPlayerPossibleGoldMines(BH_Players[BH_MinesUpdateIndex]);

    Inc(BH_MinesUpdateIndex);

    if BH_MinesUpdateIndex > High(BH_Players) then
    begin
      BH_MinesUpdateIndex := 0;
      BH_NeedToUpdate := false;
    end;
  end;

  if ((S.GameTime - 1) mod (10 * BH_Seconds) = 0) then
  begin
    BH_NeedToUpdate:= true;
  end;

  if (S.GameTime mod BH_Seconds = 0) then
  begin
    for i:= 0 to High(BH_Players) do
    begin
      BH_RefreshTips(i);
    end;
  end;
end;

{$ENDIF}
