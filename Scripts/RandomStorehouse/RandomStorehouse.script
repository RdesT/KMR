//Random storehouse placement script. With possibilities to place storehouses mirrored.
//The original script was written by Thunder.
//Rewriten by Ritter des Todes.
//01.02.2024.
//Version 1.0.
//Developed for r15122.

//To import script use {$I RandomStorehouse.script}

//----------------------------------------------------------------------------------------------------------------------------------------------------
//DESCRIPTION OF USER INTERFACE.
//----------------------------------------------------------------------------------------------------------------------------------------------------

//Initialize player, that will be affected by script and set randomising limits, serfs and workers count.
//RNST_InitPlayer(playerId, xMin, xMax, yMin, yMax : integer);

//Same as RNST_InitPlayer. Also adds starting serfs and workers count for player.
//RNST_InitPlayerEx(playerId, xMin, xMax, yMin, yMax, workersCount, serfsCount: integer);

//Bind two players. Same Bound players have mirrored locations of storehouses.
//Players should have same random coordinates range and it should be possible to place storehouse mirrored at map. Actually map should be mirrored. Good examples of maps will be Chaotica/Mercury mission.
//RNST_BindPlayers(first, second: integer);

//Sets setting for script to add some units at start after storehouse will be placed. Works only foe citizens!!! Don't add any warriors here.
//RNST_SetCitizensAtStart(playerId: integer; unitType: TKMUnitType; count: integer);

//Sets setting for script to add some resources to starting store house for all players if they have no custom settings.
//RNST_SetWaresAtStart(wareType: TKMWareType; count: integer);

//Sets custom setting for script to add some resources to starting store house for exact player.
//RNST_SetPlayerWaresAtStart(playerId: integer; wareType: TKMWareType; count: integer);

//Unlock building types for player at start.
//RNST_SetUnlockedBuildingTypes(playerId: integer; houseTypes : TKMHouseTypeSet);

//Set custom sight radius for player.
//RNST_SetPlayerSightRadius(playerId, radius: integer);

//Custom sight radius for all players. Default value is 20.
//RNST_SightRadius : integer;

//Custom cinematic length. In ticks. Default value is 60. Don't make it lower then 30. It's pointless and script will not work.
//RNST_CinematicLength : integer;

//Is cinematics needed.
//RNST_CinematicDisabled : boolean;

//----------------------------------------------------------------------------------------------------------------------------------------------------
//USING EXAMPLE.
//----------------------------------------------------------------------------------------------------------------------------------------------------

//procedure OnMissionStart;
//begin

  //Init 4 players randomization will be from (15;2) to (68;234).
  //RNST_InitPlayerEx(0, 15,68,2,234);
  //RNST_InitPlayerEx(1, 15,68,2,234);

  //Init 4 players randomization will be from (15;2) to (68;234). Also giving 5 serfs and workers at start.
  //RNST_InitPlayer(2, 15,68,2,234,5,5);
  //RNST_InitPlayer(3, 15,68,2,234,5,5);

  //Players 1 and 2 will have mirrored location of storehouse.
  //RNST_BindPlayers(0,1);

  //Setting starting resources for storehouse for all players.
  //RNST_SetWaresAtStart(wtStone,80);
  //RNST_SetWaresAtStart(wtTimber, 50);
  //RNST_SetWaresAtStart(wtGold, 60);
  //RNST_SetWaresAtStart(wtWine, 40);
  //RNST_SetWaresAtStart(wtBread, 30);
  //RNST_SetWaresAtStart(wtSausage, 15);
  //RNST_SetWaresAtStart(wtFish, 10);

  //Setting custom resource amount for player 0. He will have 100 fish instead of 10.
  //RNST_SetPlayerWaresAtStart(0, wtFish, 100);

  //Giving player 0 two additional farmers at start.
  //RNST_SetCitizensAtStart(0, utFarmer,2);

  //Unlock farm and mill at start for player 0.
  //RNST_SetUnlockedBuildingTypes(0, [htFarm, htMill]);

  //All players will have 15 tiles sight radius around storehouse at start.
  //RNST_SightRadius := 15;

  //Player 0 will have 40 tiles instead of 15 sight radius around storehouse at start.
  //RNST_SetPlayerSightRadius(0, 40);

  //7 seconds of cinematic length at start.
  //RNST_CinematicLength := 70;

  //Disable starting cinematics.
  //RNST_CinematicDisabled := true;

//end;


//That's it. Enjoy.

//----------------------------------------------------------------------------------------------------------------------------------------------------
//CODE.
//----------------------------------------------------------------------------------------------------------------------------------------------------


{$EVENT evtMissionStart:RNST_OnMissionStart}
{$EVENT evtTick:RNST_OnTick}

type RNST_WareSetting =
record
  WareType : TKMWareType;
  Count : integer;
end;

type RNST_UnitSetting =
record
  UnitType : TKMUnitType;
  Count : integer;
end;

type RNST_Player =
record
  Id: integer;

  XMIN: integer;
  XMAX: integer;
  YMIN: integer;
  YMAX: integer;

  StartingUnits: array of RNST_UnitSetting;
  StartingResourses: array of RNST_WareSetting;
  UnlockedBuildings: TKMHouseTypeSet;

  SightRadius: integer;
end;

type RNST_Binding =
record
  First: integer;
  Second: integer;
end;

const
  //Maximum coal amount tile where can be storehouse placed.
  RNST_MaxCoalAmount = 2;

  //Default sight radius for all players.
  RNST_DefaultSightRadius = 20;
  //Default cinematics length. In ticks.
  RNST_DefaultCinematicLength = 60;

var
  RNST_Players: array of RNST_Player;
  RNST_Bindings: array of RNST_Binding;
  RNST_WareSettings: array of RNST_WareSetting;

  //Custom sight radius for all players.
  RNST_SightRadius : integer;
  //Custom cinematic length. In ticks.
  RNST_CinematicLength : integer;
  //Is cinematics needed.
  RNST_CinematicDisabled : boolean;
  //Is removing initial fog of war needed.
  RNST_RemoveInitialFogDisabled : boolean;

function RNST_FindBoundPlayer(playerId: integer): integer;
var
  i: integer;

begin
  result := -1;

  for i := 0 to Length(RNST_Bindings) - 1 do
  begin
    if (RNST_Bindings[i].First = playerId)then
    begin
      result:= RNST_Bindings[i].Second;
      exit;
    end;
    if (RNST_Bindings[i].Second = playerId)then
    begin
      result:= RNST_Bindings[i].First;
      exit;
    end;
  end;
end;

function RNST_FindPlayerIndex(playerId: integer): integer;
var
  i: integer;

begin
  result := -1;

  for i := 0 to Length(RNST_Players) - 1 do
  begin
    if (RNST_Players[i].Id = playerId)then
    begin
      result:= i;
      exit;
    end;
  end;
end;

function RNST_FindUnitSettingIndex(settings: array of RNST_UnitSetting; unitType: TKMUnitType) : integer;
var
  i: integer;

begin
  result := -1;

  for i := 0 to Length(settings) - 1 do
  begin
    if (settings[i].UnitType = unitType)then
    begin
      result:= i;
      exit;
    end;
  end;
end;

function RNST_FindWareSettingIndex(settings: array of RNST_WareSetting; wareType: TKMWareType) : integer;
var
  i: integer;

begin
  result := -1;

  for i := 0 to Length(settings) - 1 do
  begin
    if (settings[i].WareType = wareType)then
    begin
      result:= i;
      exit;
    end;
  end;
end;

function RNST_GetStartingUnitsCount(unitsSettings: array of RNST_UnitSetting): integer;
var
  i: integer;
begin
  for i:=0 to Length(unitsSettings)-1 do
  begin
    result := result + unitsSettings[i].Count;
  end;
end;

function RNST_GetNextStartingUnitTypeToAdd(unitsSettings: array of RNST_UnitSetting; addedCount: integer) : TKMUnitType;
var
  i: integer;
  count: integer;
begin
  result := utNone;
  for i:=0 to Length(unitsSettings)-1 do
  begin
    count := count + unitsSettings[i].Count;
    if (count > addedCount) then
    begin
      result:= unitsSettings[i].UnitType;
      exit;
    end;
  end;
end;

function RNST_IsPossibleToMakeStoreHouse(playerId, x,y: integer): boolean;
var
  i: integer;
  j: integer;
begin

  result := false;
  for i:= (x-1) to (x+1) do
  begin

    for j:= (y-2) to y+1 do
    begin

      if (S.MapTileIsInMapCoords(i, j) = false) then
      begin
        exit;
      end;

      //If we can build, then we have no problems.
      if (S.MapTilePassabilityEx(i, j, tpBuild) = true) then
  		begin
  			continue;
  		end;

      //If we can't build without object on tile there is nothing to think about.
  		if (S.MapTilePassabilityEx(i, j, tpBuildNoObj) = false) then
  		begin
  			exit;
  		end;

      //If object that not alows to make building is a tree then we will take it away later.
      if (S.MapTilePassabilityEx(i, j, tpCutTree) = false) then
      begin
        exit;
      end;

    end;
	end;

  result:= true;

end;

function RNST_IsPossibleToMakeRoad(x,y: integer):boolean;
var
  isRoadPlaced: boolean;
begin
  isRoadPlaced := Actions.GiveRoad(0,x,y);
  if (isRoadPlaced) then
  begin
    result := true;
    Actions.RemoveRoad(x,y);
  end else
  begin
    result := false;
  end;
end;

function RNST_IsPossibleToPlaceRoadAndMove(x,y: integer) : boolean;
begin
  result := S.MapTilePassabilityEx(x,y,tpWalk) and S.MapTilePassabilityEx(x,y,tpMakeRoads);
end;

function RNST_IsResourceMountainTile(x,y: integer): boolean;
begin
  result := S.MapTileHasTerrainKind(x,y, tkGoldMount) or S.MapTileHasTerrainKind(x,y, tkIronMount) or S.MapTileHasTerrainKind(x,y, tkStone);
end;

function RNST_IsLargeCoalTile(x,y: integer): boolean;
begin
  //Low amount of coal is allowed.
  result := S.MapTileIsCoal(x,y) > RNST_MaxCoalAmount;
end;

//Go spiral way and add citizens. (Actually it's not spiral but I like the result).
procedure RNST_AddCitizens(player : RNST_Player; x,y: integer);
var
  unitsCount: integer;
  nextUnitType: TKMUnitType;

  axis : string;
  xStep : integer;
  yStep : integer;
  radius : integer;
  currentX : integer;
  currentY: integer;

  dirrectionCounter: integer;
begin

  unitsCount := RNST_GetStartingUnitsCount(player.StartingUnits);
  currentX := x;
  currentY := y;

  xStep := 1;
  yStep := 1;

  axis:= 'Y';
  dirrectionCounter:= 0;

  //27 is just wonderful number. After all citizens will be added loop will do nothing and end fast anyway.
  for radius := 1 to 27 do
  begin
    while (S.StatCitizenCount(player.Id) < unitsCount) do
    begin

      if (axis = 'Y') then
      begin

        currentY := currentY + yStep;
        if ((currentY >= (y + radius)) or (currentY <= (y - radius))) then
        begin

          xStep := -xStep;
          axis := 'X';
          Inc(dirrectionCounter)
        end;

      end else
      begin

        currentX := currentX + xStep;
        if ((currentX >= (x + radius)) or (currentX <= (x - radius))) then
        begin

          yStep := -yStep;
          axis := 'Y';
          Inc(dirrectionCounter)
        end;
      end;


      nextUnitType := RNST_GetNextStartingUnitTypeToAdd(player.StartingUnits, S.StatCitizenCount(player.Id));
      Actions.GiveUnitEx(player.Id, nextUnitType, currentX, currentY, 4);

      //We go to 4 dirrections before we increse radius.
      if (dirrectionCounter > 4) then
      begin
        dirrectionCounter:= 0;
        break;
      end;
    end;
  end;

end;

procedure RNST_AddWares(houseId: integer; settings : array of RNST_WareSetting);
var
  index : integer;
  wareType: TKMWareType;
begin

  for wareType := wtTrunk to wtFish do
  begin
    index := RNST_FindWareSettingIndex(settings, wareType);
    if (index <> -1) then
    begin
      A.HouseAddWaresToEx(houseId, wareType, settings[index].Count);
      continue;
    end;

    index := RNST_FindWareSettingIndex(RNST_WareSettings, wareType);
    if (index <> -1) then
    begin
      A.HouseAddWaresToEx(houseId, wareType, RNST_WareSettings[index].Count);
      continue;
    end;
  end;
end;

function RNST_GetTreesCount(x,y: integer): integer;
var
  i: integer;
  j: integer;
begin
	for i:= (x-1) to (x+1) do
	begin

    for j:= (y-2) to y+1 do
	  begin

      if (S.MapTilePassabilityEx(i, j, tpCutTree) = true) then
			begin
				Inc(result);
			end;
    end;
	end;
end;

function RNST_GetPlayerSightRadius(player : RNST_Player): integer;
begin
  result := U.IfThenI(player.SightRadius > 0,
            player.SightRadius,
            U.IfThenI(RNST_SightRadius > 0,
                RNST_SightRadius,
                RNST_DefaultSightRadius));
end;

function RNST_FindPlayerStoreHouseId(playerId : integer): integer;
var
  i: integer;
  houseIds : array of integer;

begin

  houseIds := States.PlayerGetAllHouses(playerId);

  for i:= 0 to Length(houseIds) -1 do
  begin
    if (S.HouseTypeEx(houseIds[i]) = htStore) then
    begin
      result := houseIds[i];
      exit;
    end;
  end;
end;

//TODO Remove when A.HouseUnlockEx will apear.
function RNST_GetHouseType(houseType : TKMHouseType):integer;
begin
  case houseType of
    htArmorSmithy   : result := 10;
    htArmorWorkshop : result := 20;
    htBakery        : result := 7;
    htBarracks      : result := 21;
    htButchers      : result := 24;
    htCoalMine      : result := 3;
    htFarm          : result := 8;
    htFishermans    : result := 6;
    htGoldMine      : result := 5;
    htInn           : result := 27;
    htIronMine      : result := 4;
    htIronSmithy    : result := 1;
    htMarket        : result := 29;
    htMetallurgists : result := 15;
    htMill          : result := 22;
    htQuarry        : result := 14;
    htSawmill       : result := 0;
    htSchool        : result := 13;
    htSiegeWorkshop : result := 23;
    htStables       : result := 12;
    htStore         : result := 11;
    htSwine         : result := 16;
    htTannery       : result := 25;
    htTownHall      : result := 18;
    htWatchTower    : result := 17;
    htWeaponSmithy  : result := 2;
    htWeaponWorkshop: result := 19;
    htVineyard      : result := 28;
    htWoodcutters   : result := 9;
  end;
end;

procedure RNST_UnlockBuildingTypes(player: RNST_Player);
var
  houseType: TKMHouseType;

begin

  for houseType := htArmorSmithy to htWoodcutters do
  begin
    if(houseType in player.UnlockedBuildings) then
    begin
      A.HouseUnlock(player.Id, RNST_GetHouseType(houseType));
    end;
  end;
end;

function RNST_TryToSetStoreHouse(playerId,x,y : integer): integer;
var
  treesCount: integer;
  index: integer;
begin

  if (not RNST_IsPossibleToMakeStoreHouse(playerId, x,y)) then
  begin
    exit;
  end;

  //Check is it possible to walk and make roads around storehouse.
  if(not RNST_IsPossibleToPlaceRoadAndMove(x  ,y+1) or  not RNST_IsPossibleToPlaceRoadAndMove(x-1,y+1) or
     not RNST_IsPossibleToPlaceRoadAndMove(x-2,y+2) or  not RNST_IsPossibleToPlaceRoadAndMove(x-2,y  ) or
     not RNST_IsPossibleToPlaceRoadAndMove(x-2,y-1) or  not RNST_IsPossibleToPlaceRoadAndMove(x-2,y-2) or
     not RNST_IsPossibleToPlaceRoadAndMove(x-2,y-3) or  not RNST_IsPossibleToPlaceRoadAndMove(x-1,y-3) or
     not RNST_IsPossibleToPlaceRoadAndMove(x  ,y-3) or  not RNST_IsPossibleToPlaceRoadAndMove(x+1,y-3) or
     not RNST_IsPossibleToPlaceRoadAndMove(x+2,y-3) or  not RNST_IsPossibleToPlaceRoadAndMove(x+2,y-2) or
     not RNST_IsPossibleToPlaceRoadAndMove(x+2,y-1) or  not RNST_IsPossibleToPlaceRoadAndMove(x+2,y  ) or
     not RNST_IsPossibleToPlaceRoadAndMove(x+2,y+1) or  not RNST_IsPossibleToPlaceRoadAndMove(x+1,y+1)) then
  begin
    exit;
  end;

  //Check that storehouse is not locatated deep in coal.
  if (RNST_IsLargeCoalTile(x-1,y) or RNST_IsLargeCoalTile(x-1,y-2) or RNST_IsLargeCoalTile(x-1,y-1)) then
  begin
    exit;
  end;

  //Check top of storhouse for gold/iron/stone mountains.
  if (RNST_IsResourceMountainTile(x-2,y-3) or RNST_IsResourceMountainTile(x-1,y-3) or
      RNST_IsResourceMountainTile(x  ,y-3) or RNST_IsResourceMountainTile(x+1,y-3) or
      RNST_IsResourceMountainTile(x+2,y-3))then
  begin
    exit;
  end;

  index := RNST_FindPlayerIndex(playerId);

  //Count trees before placing storehouse.
  treesCount := RNST_GetTreesCount(x,y);

  //This place is ok. We start placing storehouse here.
  result := A.GiveHouseEx(playerId,htStore,x,y);

  //The bonus tree trunks for trees that are gone cause we place storehouse on them.
	A.HouseAddWaresToEx(result,wtTrunk,treesCount);

  //Remove all objects in front of the storehouse.
  A.MapTileObjectSet(x,(y+1),255);
	A.MapTileObjectSet(x+1,(y+1),255);
	A.MapTileObjectSet(x-1,(y+1),255);

  //Roads in front of storehouse.
  A.GiveRoad(playerId,x  ,y+1);
	A.GiveRoad(playerId,x+1,y+1);
	A.GiveRoad(playerId,x-1,y+1);
end;

procedure RNST_PlaceRandomStorehouse(player : RNST_Player);
var
  storeHouseId: integer;
  boundPlayerStoreHouseId: integer;
  x: integer;
  y: integer;
  boundPlayer: integer;
  boundPlayerIndex : integer;
begin

  while (storeHouseId = 0) do
  begin

    x := 0;
    y := 0;
    boundPlayer := RNST_FindBoundPlayer(player.Id);
    boundPlayerIndex := RNST_FindPlayerIndex(boundPlayer);
    //If there is a bound player and storehouse for this player was placed we place storehouse using this coordinates.
    if (boundPlayerIndex <> -1) then
    begin

      boundPlayerStoreHouseId := RNST_FindPlayerStoreHouseId(boundPlayer);

      if (boundPlayerStoreHouseId > 0)then
      begin


        x := player.XMIN + (S.HousePositionX(boundPlayerStoreHouseId) - RNST_Players[boundPlayerIndex].XMIN);
        y := player.YMIN + (S.HousePositionY(boundPlayerStoreHouseId) - RNST_Players[boundPlayerIndex].YMIN);
      end;
    end;

    //If there is no bound player or bound player still has no storehouse.
    if ((x = 0) and (y = 0))then
    begin
      x := player.XMIN + (States.KamRandomI((player.XMAX-player.XMIN)))
      y := player.YMIN + (States.KamRandomI((player.YMAX-player.YMIN)));
    end;

    storeHouseId := RNST_TryToSetStoreHouse(player.Id,x,y);
    if (storeHouseId <> 0) then
    begin
      //Adding wares to storehouse.
      RNST_AddWares(storeHouseId, player.StartingResourses);
      RNST_UnlockBuildingTypes(player);

      if (not RNST_RemoveInitialFogDisabled) then
      begin
        A.FogCoverAll(player.Id);
      end;

      //Reveal huge area for vision.
	    A.FogRevealCircle(player.Id,x,y, RNST_GetPlayerSightRadius(player));

      RNST_AddCitizens(player, x, y);
    end;
  end;
end;

//----------------------------------------------------------------------------------------------------------------------------------------------------
//Public interface------------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------------------------

//Bind two players. Same Bound players have mirrored locations of storehouses.
//first - first player id.
//second - second player id.
procedure RNST_BindPlayers(first, second: integer);
var
  count: integer;
  newBinding: RNST_Binding;
begin
  //Player can be bound only once.
  if ((RNST_FindBoundPlayer(first) <> -1) or (RNST_FindBoundPlayer(second) <> -1)) then
  begin
    exit;
  end;

  count := Length(RNST_Bindings);
  newBinding.First := first;
  newBinding.Second := second;
  setLength(RNST_Bindings, count + 1);
  RNST_Bindings[count] := newBinding;
end;

//Sets setting for script to add some units at start after storehouse will be placed. Works only foe citizens!!! Don't add any warriors here.
//playerId - id of player, that will have this units at start.
//unitType - type of units you want to add.
//count - the amount of units.
procedure RNST_SetCitizensAtStart(playerId: integer; unitType: TKMUnitType; count: integer);
var
  playerIndex : integer;
  settingIndex : integer;
  settingsCount : integer;
  newSetting : RNST_UnitSetting;

begin

  playerIndex := RNST_FindPlayerIndex(playerId);

  if (playerIndex = -1) then
  begin
    exit;
  end;

  settingIndex := RNST_FindUnitSettingIndex(RNST_PLayers[playerIndex].StartingUnits, unitType);

  if (settingIndex >= 0) then
  begin
    RNST_Players[playerIndex].StartingUnits[settingIndex].Count := count;
  end else
  begin
    settingsCount := Length(RNST_Players[playerIndex].StartingUnits);
    newSetting.UnitType := unitType;
    newSetting.Count := count;
    setLength(RNST_Players[playerIndex].StartingUnits, settingsCount + 1);
    RNST_Players[playerIndex].StartingUnits[settingsCount] := newSetting;
  end;
end;

//Sets custom setting for script to add some resources to starting store house for exact player.
//playerId - id of player, that will have this units at start.
//wareType - type of resource you want to add.
//count - the amount of units.
procedure RNST_SetPlayerWaresAtStart(playerId: integer; wareType: TKMWareType; count: integer);
var
  playerIndex : integer;
  settingIndex : integer;
  settingsCount : integer;
  newSetting : RNST_WareSetting;

begin

  playerIndex := RNST_FindPlayerIndex(playerId);

  if (playerIndex = -1) then
  begin
    exit;
  end;

  settingIndex := RNST_FindWareSettingIndex(RNST_PLayers[playerIndex].StartingResourses, wareType);

  if (settingIndex >= 0) then
  begin
    RNST_Players[playerIndex].StartingUnits[settingIndex].Count := count;
  end else
  begin
    settingsCount := Length(RNST_Players[playerIndex].StartingResourses);
    newSetting.WareType := wareType;
    newSetting.Count := count;
    setLength(RNST_Players[playerIndex].StartingResourses, settingsCount + 1);
    RNST_Players[playerIndex].StartingResourses[settingsCount] := newSetting;
  end;
end;

//Sets setting for script to add some resources to starting store house for all players if they have no custom settings.
//wareType - type of resource you want to add.
//count - the amount of units.
procedure RNST_SetWaresAtStart(wareType: TKMWareType; count: integer);
var
  settingIndex : integer;
  settingsCount : integer;
  newSetting : RNST_WareSetting;

begin

  settingIndex := RNST_FindWareSettingIndex(RNST_WareSettings, wareType);

  if (settingIndex >= 0) then
  begin
    RNST_WareSettings[settingIndex].Count := count;
  end else
  begin
    settingsCount := Length(RNST_WareSettings);
    newSetting.WareType := wareType;
    newSetting.Count := count;
    setLength(RNST_WareSettings, settingsCount + 1);
    RNST_WareSettings[settingsCount] := newSetting;
  end;
end;

//Unlock building types for player at start.
//playerId - id of player, that will get this bonus.
//houseTypes - set of building types, that will be unlocked.
procedure RNST_SetUnlockedBuildingTypes(playerId: integer; houseTypes : TKMHouseTypeSet);
var
  index: integer;

begin

  index:= RNST_FindPlayerIndex(playerId);
  if (index = -1) then
  begin
    exit;
  end;

  RNST_Players[index].UnlockedBuildings := RNST_Players[index].UnlockedBuildings + houseTypes;
end;

//Set custom sight radius for player.
//playerId - id of player, that will have this radius.
//radius - sight radius
procedure RNST_SetPlayerSightRadius(playerId, radius: integer);
var
  index: integer;
begin
  index:= RNST_FindPlayerIndex(playerId);
  if (index = -1) then
  begin
    exit;
  end;

  RNST_Players[index].SightRadius := radius;
end;

//Initializing player for script.
//playerId - id of player, that will have this units at start.
//xMin - minimum X value.
//xMax - maximum X value.
//yMin - minimum Y value.
//yMax - maximum Y value.
procedure RNST_InitPlayer(playerId, xMin, xMax, yMin, yMax : integer);
var
  index: integer;
  count: integer;
  newPlayer: RNST_Player;
begin

  index:= RNST_FindPlayerIndex(playerId);
  if (index >= 0) then
  begin
    exit;
  end;
  count := Length(RNST_Players);

  newPlayer.Id := playerId;
  newPlayer.XMIN := xMin;
  newPlayer.XMAX := xMax;
  newPlayer.YMIN := yMin;
  newPlayer.YMAX := yMax;

  setLength(RNST_Players, count + 1);
  RNST_Players[count] := newPlayer;
end;

//Initializing player for script.
//Same as RNST_InitPlayer, but here you can also add starting serfs and workers count.
//workersCount - the amount of workers at start.
//serfsCount - the amount of serfs at start.
procedure RNST_InitPlayerEx(playerId, xMin, xMax, yMin, yMax, workersCount, serfsCount: integer);
begin

  RNST_InitPlayer(playerId, xMin, xMax, yMin, yMax);
  RNST_SetCitizensAtStart(playerId, utSerf, serfsCount);
  RNST_SetCitizensAtStart(playerId, utBuilder, workersCount);
end;


//----------------------------------------------------------------------------------------------------------------------------------------------------
//Events----------------------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------------------------


procedure RNST_OnMissionStart;
var
  i: integer;
begin

  for i:= 0 to Length(RNST_Players) -1 do
  begin
    if (S.PlayerEnabled(i)) then
    begin
      RNST_PlaceRandomStorehouse(RNST_Players[i]);
    end;
  end;

end;

procedure RNST_OnTick;
var
  i: Integer;
  storeHouseId: integer;
begin

  if (RNST_CinematicDisabled)then
  begin
    exit;
  end;

	if S.GameTime = 2 then
	begin

		for i := 0 to Length(RNST_Players) - 1 do
    begin

			if S.PlayerEnabled(RNST_Players[i].Id) then
      begin
				A.CinematicStart(i);
      end;
    end;
	end;


	if States.GameTime = 30 then
	begin

		for i := 0 to Length(RNST_Players) - 1 do
    begin

			if (S.PlayerEnabled(RNST_Players[i].Id)) then
      begin
        storeHouseId := RNST_FindPlayerStorehouseId(RNST_Players[i].Id);
				A.CinematicPanTo(i,S.HousePositionX(storeHouseId),S.HousePositionY(storeHouseId),4);
      end;
    end;
	end;

	if States.GameTime = U.IfThenI(RNST_CinematicLength > 0, RNST_CinematicLength, RNST_DefaultCinematicLength) then
	begin

		for i := 0 to Length(RNST_Players) - 1 do
    begin

			if S.PlayerEnabled(i) then
			begin;
      	A.CinematicEnd(i);
      end;
    end;
	end;
end;

